<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>find Median from Data Stream - DSA Solutions</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.8;
        color: #333;
        background: #f5f7fa;
      }

      /* Header Navigation */
      .top-nav {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 0;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 1000;
      }

      .nav-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
      }

      .nav-brand {
        font-size: 1.3em;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .nav-brand a {
        color: white;
        text-decoration: none;
      }

      .nav-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .nav-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 6px;
        text-decoration: none;
      }

      .nav-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
      }

      .nav-btn.primary {
        background: white;
        color: #667eea;
        font-weight: 600;
      }

      .nav-btn.primary:hover {
        background: #f8f9fa;
      }

      /* Main Container */
      .container {
        max-width: 1200px;
        margin: 30px auto;
        padding: 0 20px;
      }

      /* Question Navigation */
      .question-nav {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
      }

      .nav-group {
        display: flex;
        gap: 10px;
      }

      .question-btn {
        padding: 12px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
        color: white;
        text-decoration: none;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      }

      .question-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
      }

      .question-btn:disabled {
        background: #e0e0e0;
        color: #999;
        cursor: not-allowed;
        box-shadow: none;
      }

      .question-btn span {
        font-size: 16px;
      }

      /* Search Bar */
      .search-container {
        position: relative;
        flex: 1;
        min-width: 250px;
        max-width: 400px;
      }

      .search-input {
        width: 100%;
        padding: 10px 40px 10px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 14px;
        transition: all 0.3s;
      }

      .search-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .search-icon {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #999;
      }

      /* Question Header */
      .question-header {
        background: white;
        border-radius: 12px;
        padding: 30px;
        margin-bottom: 25px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }

      .question-title {
        font-size: 2em;
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 15px;
      }

      .question-meta {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
      }

      .difficulty-badge {
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 600;
      }

      .difficulty-easy {
        background: #d4edda;
        color: #155724;
      }

      .difficulty-medium {
        background: #fff3cd;
        color: #856404;
      }

      .difficulty-hard {
        background: #f8d7da;
        color: #721c24;
      }

      .topic-tag {
        background: #e7f3ff;
        color: #0066cc;
        padding: 6px 14px;
        border-radius: 16px;
        font-size: 13px;
        font-weight: 500;
      }

      /* Action Buttons */
      .action-buttons {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .action-btn {
        padding: 10px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      }

      .action-btn.secondary {
        background: white;
        color: #667eea;
        border: 2px solid #667eea;
      }

      .action-btn.secondary:hover {
        background: #f8f9fa;
      }

      /* Content Area */
      .content-wrapper {
        background: white;
        border-radius: 12px;
        padding: 40px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        margin-bottom: 25px;
        line-height: 1.9;
      }

      .content-wrapper h1,
      .content-wrapper h2,
      .content-wrapper h3 {
        color: #2c3e50;
        margin-top: 35px;
        margin-bottom: 18px;
        padding-bottom: 12px;
        border-bottom: 3px solid #667eea;
        font-weight: 700;
      }

      .content-wrapper h1 {
        font-size: 2em;
        color: #667eea;
      }

      .content-wrapper h2 {
        font-size: 1.6em;
        border-bottom: 2px solid #764ba2;
      }

      .content-wrapper h3 {
        font-size: 1.35em;
        border-bottom: 2px solid #e0e0e0;
      }

      .content-wrapper h1:first-child,
      .content-wrapper h2:first-child,
      .content-wrapper h3:first-child {
        margin-top: 0;
      }

      .content-wrapper p {
        margin-bottom: 18px;
        color: #444;
        font-size: 16px;
      }

      .content-wrapper ul,
      .content-wrapper ol {
        margin-left: 30px;
        margin-bottom: 20px;
      }

      .content-wrapper li {
        margin-bottom: 10px;
        color: #555;
        line-height: 1.8;
      }

      .content-wrapper strong {
        color: #2c3e50;
        font-weight: 600;
      }

      .content-wrapper em {
        color: #667eea;
      }

      /* Code Blocks */
      .content-wrapper pre {
        background: #2d2d2d;
        border: 1px solid #444;
        border-radius: 10px;
        padding: 24px;
        overflow-x: auto;
        margin: 25px 0;
        position: relative;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .content-wrapper code {
        font-family: "Consolas", "Monaco", "Courier New", Courier, monospace;
        font-size: 14px;
        line-height: 1.7;
        color: #f8f8f2;
      }

      .content-wrapper p code,
      .content-wrapper li code {
        background: #fff4e6;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 0.9em;
        border: 1px solid #ffe0b2;
        color: #d84315;
        font-weight: 500;
      }

      /* Copy Button for Code */
      .code-block {
        position: relative;
      }

      .copy-code-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        opacity: 0.8;
        transition: all 0.3s;
      }

      .copy-code-btn:hover {
        opacity: 1;
      }

      .copy-code-btn.copied {
        background: #28a745;
      }

      /* Toast Notification */
      .toast {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background: #28a745;
        color: white;
        padding: 15px 25px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        transform: translateY(100px);
        opacity: 0;
        transition: all 0.3s;
        z-index: 2000;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toast.show {
        transform: translateY(0);
        opacity: 1;
      }

      /* Footer */
      footer {
        background: white;
        border-radius: 12px;
        padding: 25px;
        text-align: center;
        color: #666;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        margin-top: 30px;
      }

      footer a {
        color: #667eea;
        text-decoration: none;
        font-weight: 600;
      }

      footer a:hover {
        text-decoration: underline;
      }

      /* Tablet Responsive */
      @media (max-width: 1024px) {
        .container {
          margin: 20px 10px;
        }

        h1 {
          font-size: 2em;
        }

        .content-wrapper {
          padding: 25px;
        }
      }

      /* Mobile Responsive */
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }

        .container {
          margin: 0;
          border-radius: 15px;
        }

        .top-nav {
          padding: 12px 0;
        }

        .nav-container {
          flex-direction: column;
          align-items: flex-start;
          padding: 0 15px;
        }

        .nav-brand {
          font-size: 1.1em;
        }

        .nav-actions {
          width: 100%;
          justify-content: stretch;
        }

        .nav-btn {
          flex: 1;
          justify-content: center;
          font-size: 13px;
          padding: 7px 12px;
        }

        header {
          padding: 30px 20px;
        }

        h1 {
          font-size: 1.8em;
        }

        .stats {
          gap: 10px;
        }

        .stat-item {
          padding: 8px 15px;
          min-width: 80px;
        }

        .stat-number {
          font-size: 1.5em;
        }

        .question-nav {
          flex-direction: column;
          align-items: stretch;
          padding: 15px;
          gap: 10px;
        }

        .nav-group {
          justify-content: space-between;
          width: 100%;
        }

        .question-btn {
          flex: 1;
          padding: 10px 15px;
          font-size: 13px;
        }

        .search-container {
          max-width: 100%;
          order: -1;
        }

        .search-input {
          font-size: 15px;
        }

        .question-header {
          padding: 20px;
        }

        .question-title {
          font-size: 1.4em;
          line-height: 1.3;
        }

        .question-meta {
          gap: 10px;
        }

        .difficulty-badge {
          padding: 5px 12px;
          font-size: 13px;
        }

        .topic-tag {
          padding: 5px 10px;
          font-size: 12px;
        }

        .action-buttons {
          flex-direction: column;
          padding: 15px;
        }

        .action-btn {
          width: 100%;
          justify-content: center;
          padding: 12px 20px;
        }

        .content-wrapper {
          padding: 20px 15px;
        }

        .content-wrapper h1 {
          font-size: 1.5em;
        }

        .content-wrapper h2 {
          font-size: 1.3em;
        }

        .content-wrapper h3 {
          font-size: 1.15em;
        }

        .content-wrapper pre {
          padding: 15px;
          font-size: 13px;
          overflow-x: auto;
        }

        .copy-code-btn {
          font-size: 11px;
          padding: 5px 10px;
        }

        .toast {
          right: 10px;
          left: 10px;
          bottom: 10px;
          padding: 12px 20px;
          font-size: 14px;
        }

        footer {
          padding: 20px 15px;
          font-size: 14px;
        }
      }

      /* Small Mobile */
      @media (max-width: 480px) {
        .nav-brand {
          font-size: 1em;
        }

        h1 {
          font-size: 1.5em;
        }

        .question-title {
          font-size: 1.2em;
        }

        .question-btn {
          padding: 8px 10px;
          font-size: 12px;
        }

        .question-btn span {
          display: none;
        }

        .action-btn {
          font-size: 13px;
          padding: 10px 15px;
        }

        .stat-item {
          padding: 6px 10px;
          font-size: 13px;
        }

        .content-wrapper {
          padding: 15px 10px;
        }

        .content-wrapper pre {
          padding: 12px;
          font-size: 12px;
        }
      }

      /* Loading Animation */
      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Print Styles */
      @media print {
        .top-nav,
        .question-nav,
        .action-buttons,
        .toast {
          display: none;
        }

        .container {
          max-width: 100%;
          margin: 0;
          padding: 0;
        }

        .content-wrapper {
          box-shadow: none;
          padding: 0;
        }
      }
    </style>
  </head>
  <body>
    <!-- Top Navigation -->
    <nav class="top-nav">
      <div class="nav-container">
        <div class="nav-brand">
          <span>üöÄ</span>
          <a href="index.html">DSA Questions</a>
        </div>
        <div class="nav-actions">
          <a href="index.html" class="nav-btn primary">
            <span>üìö</span> All Questions
          </a>
          <button onclick="toggleTheme()" class="nav-btn">
            <span id="theme-icon">üåô</span> Theme
          </button>
        </div>
      </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
      <!-- Question Navigation -->
      <div class="question-nav">
        <div class="nav-group">
          <button class="question-btn" id="prevBtn" onclick="navigateToPrev()">
            <span>‚Üê</span> Previous
          </button>
          <button class="question-btn" id="nextBtn" onclick="navigateToNext()">
            Next <span>‚Üí</span>
          </button>
        </div>
        <div class="search-container">
          <input
            type="text"
            class="search-input"
            id="searchInput"
            placeholder="Search questions..."
          />
          <span class="search-icon">üîç</span>
        </div>
        <div class="nav-group">
          <button class="question-btn" onclick="showRandomQuestion()">
            <span>üé≤</span> Random
          </button>
        </div>
      </div>

      <!-- Question Header -->
      <div class="question-header">
        <h1 class="question-title" id="questionTitle">find Median from Data Stream</h1>
        <div class="question-meta" id="questionMeta">
          <span class="difficulty-badge difficulty-medium"
            >Medium</span
          >
          <span class="topic-tag">Tree</span><span class="topic-tag">BFS</span><span class="topic-tag">Graph</span><span class="topic-tag">Hash Table</span><span class="topic-tag">Array</span>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="action-buttons">
        <button class="action-btn" onclick="copyContent()">
          <span>üìã</span> Copy All
        </button>
        <button class="action-btn" onclick="copyCode()">
          <span>üíª</span> Copy Code
        </button>
        <button class="action-btn secondary" onclick="exportToPDF()">
          <span>üìÑ</span> Export PDF
        </button>
        <button class="action-btn secondary" onclick="exportToMarkdown()">
          <span>üìù</span> Export MD
        </button>
        <button class="action-btn secondary" onclick="shareQuestion()">
          <span>üîó</span> Share
        </button>
      </div>

      <!-- Question Content -->
      <div class="content-wrapper" id="questionContent"><p>Find Median from Data Stream</p>

<p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>

<p>For example, for arr = [2,3,4], the median is 3.
For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.
Implement the MedianFinder class:</p>

<p>MedianFinder() initializes the MedianFinder object.
void addNum(int num) adds the integer num from the data stream to the data structure.
double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.</p>

<p>Example 1:</p>

<p>Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]</p>

<p>Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1); // arr = [1]
medianFinder.addNum(2); // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3); // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0</p>

<p>Constraints:</p>

<p>-10^5 <= num <= 10^5
There will be at least one element in the data structure before calling findMedian.
At most 5 \* 10^4 calls will be made to addNum and findMedian.</p>

<p>Follow up:</p>

<p>If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?
If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?</p>

<p>this is the classic <strong>Median from Data Stream</strong> problem. Below is an interview-ready answer you can speak to the interviewer, plus a clean Java implementation (two-heap approach), complexity, tests, and answers to the two follow-up questions.</p>

<p>---</p>

<h2>Short script to say to the interviewer</h2>

<ol>
<li>‚ÄúI'll maintain two heaps: a max-heap <code>low</code> for the smaller half of numbers, and a min-heap <code>high</code> for the larger half.‚Äù</li>
<li>‚ÄúOn <code>addNum</code>, push the new number into one heap (based on value), then rebalance so that <code>low.size()</code> is either equal to <code>high.size()</code> or exactly one larger. That invariant makes <code>findMedian()</code> O(1): if sizes equal, median = average of <code>low.peek()</code> and <code>high.peek()</code>; otherwise median = <code>low.peek()</code>.‚Äù</li>
<li>‚ÄúThis gives <code>addNum</code> in O(log n) and <code>findMedian</code> in O(1).‚Äù</li>
</ol>

<p>---</p>

<h2>Why two heaps works (intuition)</h2>

<ul>
<li>Maintain invariant: every value in <code>low</code> ‚â§ every value in <code>high</code>. <code>low</code> is a max-heap so we can quickly get the largest of the lower half; <code>high</code> is a min-heap so we can quickly get the smallest of the upper half.</li>
<li>By keeping sizes balanced (difference ‚â§ 1) we ensure the median is at the top of one or both heaps.</li>
</ul>

<p>---</p>

<h2>Complexity</h2>

<ul>
<li><code>addNum</code>: O(log n) for heap insert + possible move between heaps.</li>
<li><code>findMedian</code>: O(1).</li>
<li>Space: O(n) to store the numbers.</li>
</ul>

<p>---</p>

<h2>Java implementation (clean & production-ready)</h2>

<p><pre><code>import java.util.PriorityQueue;
import java.util.Collections;

public class MedianFinder {
    // Max-heap for the lower half
    private PriorityQueue<Integer> low;
    // Min-heap for the upper half
    private PriorityQueue<Integer> high;

    /** initialize your data structure here. */
    public MedianFinder() {
        low = new PriorityQueue<>(Collections.reverseOrder());
        high = new PriorityQueue<>();
    }

    public void addNum(int num) {
        // Add to low first (max-heap). Then move the max of low to high to maintain order,
        // and finally rebalance sizes so low may have 1 more element than high.
        if (low.isEmpty() || num <= low.peek()) {
            low.offer(num);
        } else {
            high.offer(num);
        }

        // Rebalance sizes: ensure low.size() >= high.size() and difference <= 1
        if (low.size() < high.size()) {
            low.offer(high.poll());
        } else if (low.size() - high.size() > 1) {
            high.offer(low.poll());
        }
    }

    public double findMedian() {
        if (low.size() == high.size()) {
            // even count
            return ((double) low.peek() + (double) high.peek()) / 2.0;
        } else {
            // odd count; low has one extra element
            return (double) low.peek();
        }
    }

    // quick example
    public static void main(String[] args) {
        MedianFinder mf = new MedianFinder();
        mf.addNum(1);
        mf.addNum(2);
        System.out.println(mf.findMedian()); // 1.5
        mf.addNum(3);
        System.out.println(mf.findMedian()); // 2.0

        // more tests
        MedianFinder mf2 = new MedianFinder();
        mf2.addNum(5);
        System.out.println(mf2.findMedian()); // 5.0
        mf2.addNum(-1);
        System.out.println(mf2.findMedian()); // 2.0
    }
}</code></pre></p>

<p>---</p>

<h2>Edge cases & tests to mention</h2>

<ul>
<li>Single element ‚Üí median is that element.</li>
<li>Even count ‚Üí median is average of two middle values; return double.</li>
<li>Negative numbers and duplicates handled naturally by heaps.</li>
<li>Up to 5√ó10‚Å¥ operations ‚Äî O(log n) per add is fine.</li>
</ul>

<p>---</p>

<h2>Follow-up 1 ‚Äî if all numbers are in range [0, 100]</h2>

<p>If every number lies in a small fixed range [0..100], you can do much better than heaps:</p>

<strong>Approach:</strong> use a counting array <code>count[0..100]</code> and keep <code>totalCount</code>. To find median, scan cumulative counts from 0 upward until you reach the middle position(s). Because the range size is constant (101), scanning is O(1) time (i.e., O(101) ~ constant) and update <code>addNum</code> is O(1) (increment a counter). So:

<ul>
<li><code>addNum</code>: O(1)</li>
<li><code>findMedian</code>: O(101) ‚âà O(1)</li>
</ul>

<p>This is very fast and memory-efficient.</p>

<p>---</p>

<h2>Follow-up 2 ‚Äî if 99% numbers are in [0,100] and the rest are arbitrary</h2>

<p>When most numbers are in [0..100] but some are outside, blend techniques:</p>

<strong>Option A ‚Äî two-structure hybrid (recommended):</strong>

<ul>
<li>Keep <code>count[0..100]</code> for the frequent range.</li>
<li>Keep two heaps (or an ordered structure) only for out-of-range numbers (those <0 or >100).</li>
<li>Also track counts of how many values in the count-array vs heaps so you can find the median target position.</li>
<li>For <code>findMedian</code>, you first check whether the median position(s) fall inside the <code>[0..100]</code> bucket via cumulative counts: if yes, scan the small array to find the median; if not, determine whether it falls in the lower out-of-range set or upper out-of-range set and query the heaps/ordered-set accordingly.</li>
</ul>
  This keeps <code>addNum</code> still O(1) for 99% of cases and <code>findMedian</code> typically O(1) if median lies in [0..100]. Only occasionally you pay log n to handle outliers.

<strong>Option B ‚Äî keep counts + balanced BST (TreeMap) for outliers:</strong>

<ul>
<li><code>count[0..100]</code> as before and a <code>TreeMap<Integer, Integer></code> for outliers.</li>
<li>To find median: check counts in [0..100] first; if median falls in TreeMap, walk TreeMap cumulatively (log n keys) ‚Äî still quite fast because few outliers exist.</li>
</ul>

<p>Both hybrid options are practical. The key point to state in an interview: exploit the small dense bucket for constant-time operations and handle sparse outliers with a separate structure.</p></div>

      <!-- Footer -->
      <footer>
        <p><strong>Part of DSA Questions Collection</strong></p>
        <p>
          <a href="index.html">Browse All Questions</a> ‚Ä¢
          <a
            href="https://github.com/pranavlonari/dsa-questions"
            target="_blank"
            >GitHub</a
          >
          ‚Ä¢
          <a href="#" onclick="window.print(); return false;">Print</a>
        </p>
        <p style="margin-top: 10px; font-size: 0.9em">
          üí° Interview-ready solutions with detailed explanations
        </p>
      </footer>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast">
      <span>‚úì</span>
      <span id="toastMessage">Copied to clipboard!</span>
    </div>

    <script>
      // Question data from questions.json
      let questionsData = [];
      let currentQuestionIndex = -1;

      // Load questions data
      async function loadQuestionsData() {
        try {
          const response = await fetch("questions.json");
          questionsData = (await response.json()).questions;
          initializeNavigation();
        } catch (error) {
          console.error("Error loading questions:", error);
        }
      }

      // Initialize navigation
      function initializeNavigation() {
        const currentFileName = getCurrentFileName();
        console.log("Current file:", currentFileName);
        console.log("Questions data:", questionsData);

        currentQuestionIndex = questionsData.findIndex(
          (q) => q.fileName === currentFileName
        );

        console.log("Current index:", currentQuestionIndex);

        // Update prev/next buttons
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");

        if (currentQuestionIndex <= 0) {
          prevBtn.disabled = true;
          prevBtn.style.opacity = "0.5";
          prevBtn.style.cursor = "not-allowed";
        } else {
          prevBtn.disabled = false;
          prevBtn.style.opacity = "1";
          prevBtn.style.cursor = "pointer";
        }

        if (
          currentQuestionIndex >= questionsData.length - 1 ||
          currentQuestionIndex === -1
        ) {
          nextBtn.disabled = true;
          nextBtn.style.opacity = "0.5";
          nextBtn.style.cursor = "not-allowed";
        } else {
          nextBtn.disabled = false;
          nextBtn.style.opacity = "1";
          nextBtn.style.cursor = "pointer";
        }

        // Add code copy buttons
        addCopyButtonsToCode();
      }

      // Get current file name
      function getCurrentFileName() {
        const path = window.location.pathname;
        let fileName = decodeURIComponent(
          path.substring(path.lastIndexOf("/") + 1)
        );
        // Remove .html extension
        if (fileName.endsWith(".html")) {
          fileName = fileName.slice(0, -5);
        }
        return fileName || "find Median from Data Stream";
      }

      // Navigate to previous question
      function navigateToPrev() {
        if (currentQuestionIndex > 0) {
          const prevQuestion = questionsData[currentQuestionIndex - 1];
          window.location.href =
            encodeURIComponent(prevQuestion.fileName) + ".html";
        }
      }

      // Navigate to next question
      function navigateToNext() {
        if (
          currentQuestionIndex < questionsData.length - 1 &&
          currentQuestionIndex !== -1
        ) {
          const nextQuestion = questionsData[currentQuestionIndex + 1];
          window.location.href =
            encodeURIComponent(nextQuestion.fileName) + ".html";
        }
      }

      // Show random question
      function showRandomQuestion() {
        if (questionsData.length > 0) {
          const randomIndex = Math.floor(Math.random() * questionsData.length);
          const randomQuestion = questionsData[randomIndex];
          window.location.href =
            encodeURIComponent(randomQuestion.fileName) + ".html";
        }
      }

      // Search functionality
      document.getElementById("searchInput")?.addEventListener("input", (e) => {
        const searchTerm = e.target.value.toLowerCase();
        if (searchTerm.length > 2) {
          const results = questionsData.filter(
            (q) =>
              q.title.toLowerCase().includes(searchTerm) ||
              q.topics.some((t) => t.toLowerCase().includes(searchTerm))
          );
          // Could show dropdown with results
          console.log("Search results:", results);
        }
      });

      // Copy all content
      function copyContent() {
        const content = document.getElementById("questionContent").innerText;
        copyToClipboard(content, "All content copied!");
      }

      // Copy only code blocks
      function copyCode() {
        const codeBlocks = document.querySelectorAll(
          "#questionContent pre code"
        );
        let allCode = "";
        codeBlocks.forEach((block, index) => {
          if (index > 0) allCode += "\n\n// ================\n\n";
          allCode += block.innerText;
        });

        if (allCode) {
          copyToClipboard(allCode, "Code copied!");
        } else {
          showToast("No code found!", "error");
        }
      }

      // Copy to clipboard helper
      function copyToClipboard(text, message) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast(message);
          })
          .catch((err) => {
            console.error("Failed to copy:", err);
            showToast("Failed to copy!", "error");
          });
      }

      // Show toast notification
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const toastMessage = document.getElementById("toastMessage");

        toastMessage.textContent = message;
        toast.style.background = type === "error" ? "#dc3545" : "#28a745";
        toast.classList.add("show");

        setTimeout(() => {
          toast.classList.remove("show");
        }, 3000);
      }

      // Export to PDF
      function exportToPDF() {
        showToast("Preparing PDF...", "success");
        setTimeout(() => {
          window.print();
        }, 500);
      }

      // Export to Markdown
      function exportToMarkdown() {
        const title = document.getElementById("questionTitle").innerText;
        const content = document.getElementById("questionContent").innerText;

        const markdown = `# ${title}\n\n${content}`;

        const blob = new Blob([markdown], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${title}.md`;
        a.click();
        URL.revokeObjectURL(url);

        showToast("Markdown exported!");
      }

      // Share question
      function shareQuestion() {
        const title = document.getElementById("questionTitle").innerText;
        const url = window.location.href;

        if (navigator.share) {
          navigator
            .share({
              title: title,
              url: url,
            })
            .then(() => {
              showToast("Shared successfully!");
            })
            .catch(() => {
              copyToClipboard(url, "Link copied!");
            });
        } else {
          copyToClipboard(url, "Link copied!");
        }
      }

      // Add copy buttons to code blocks
      function addCopyButtonsToCode() {
        const codeBlocks = document.querySelectorAll("#questionContent pre");
        codeBlocks.forEach((block, index) => {
          const button = document.createElement("button");
          button.className = "copy-code-btn";
          button.innerHTML = "üìã Copy";
          button.onclick = function () {
            const code =
              block.querySelector("code")?.innerText || block.innerText;
            copyToClipboard(code, "Code copied!");
            button.innerHTML = "‚úì Copied";
            button.classList.add("copied");
            setTimeout(() => {
              button.innerHTML = "üìã Copy";
              button.classList.remove("copied");
            }, 2000);
          };
          block.style.position = "relative";
          block.appendChild(button);
        });
      }

      // Theme toggle (optional)
      function toggleTheme() {
        // Implement dark mode if desired
        showToast("Theme toggle coming soon!");
      }

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        // Alt + Left Arrow - Previous
        if (e.altKey && e.key === "ArrowLeft") {
          navigateToPrev();
        }
        // Alt + Right Arrow - Next
        if (e.altKey && e.key === "ArrowRight") {
          navigateToNext();
        }
        // Ctrl + K - Search
        if (e.ctrlKey && e.key === "k") {
          e.preventDefault();
          document.getElementById("searchInput").focus();
        }
      });

      // Initialize on page load
      loadQuestionsData();
    </script>
  </body>
</html>
