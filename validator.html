<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Repository Validator - DSA Questions</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        max-width: 900px;
        margin: 40px auto;
        padding: 20px;
        background: #f5f5f5;
      }
      .container {
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        color: #333;
        border-bottom: 3px solid #667eea;
        padding-bottom: 10px;
      }
      .status {
        padding: 15px;
        margin: 15px 0;
        border-radius: 5px;
        font-weight: bold;
      }
      .success {
        background: #d4edda;
        color: #155724;
        border-left: 4px solid #28a745;
      }
      .error {
        background: #f8d7da;
        color: #721c24;
        border-left: 4px solid #dc3545;
      }
      .warning {
        background: #fff3cd;
        color: #856404;
        border-left: 4px solid #ffc107;
      }
      .info {
        background: #d1ecf1;
        color: #0c5460;
        border-left: 4px solid #17a2b8;
      }
      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 5px;
      }
      button:hover {
        opacity: 0.9;
      }
      .results {
        margin-top: 30px;
      }
      .result-item {
        padding: 10px;
        margin: 10px 0;
        border-left: 3px solid #667eea;
        background: #f8f9fa;
      }
      ul {
        margin: 10px 0;
        padding-left: 30px;
      }
      li {
        margin: 5px 0;
      }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 20px 0;
      }
      .stat-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      }
      .stat-number {
        font-size: 2.5em;
        font-weight: bold;
      }
      .stat-label {
        font-size: 0.9em;
        opacity: 0.9;
      }
      code {
        background: #f4f4f4;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üîç DSA Repository Validator</h1>

      <div class="status info">
        <strong>‚ÑπÔ∏è Purpose:</strong> This tool validates the consistency of your
        DSA questions repository by checking questions.json against actual
        files.
      </div>

      <div style="margin: 20px 0">
        <button onclick="loadAndValidate()">üöÄ Validate Repository</button>
        <button onclick="generateReport()">üìä Generate Report</button>
      </div>

      <div id="results" class="results"></div>
    </div>

    <script>
      let questionsData = null;

      async function loadAndValidate() {
        const resultsDiv = document.getElementById("results");
        resultsDiv.innerHTML =
          '<div class="status info">Loading questions.json...</div>';

        try {
          const response = await fetch("questions.json");
          if (!response.ok) {
            throw new Error("Failed to load questions.json");
          }
          questionsData = await response.json();

          const validation = validateData(questionsData);
          displayResults(validation);
        } catch (error) {
          resultsDiv.innerHTML = `<div class="status error">‚ùå Error: ${error.message}</div>`;
        }
      }

      function validateData(data) {
        const results = {
          success: [],
          warnings: [],
          errors: [],
          stats: {},
        };

        // Validate metadata
        if (data.metadata && data.questions) {
          const actualCount = data.questions.length;
          const declaredCount = data.metadata.totalQuestions;

          if (actualCount === declaredCount) {
            results.success.push(`‚úÖ Question count matches: ${actualCount}`);
          } else {
            results.errors.push(
              `‚ùå Question count mismatch: declared ${declaredCount}, found ${actualCount}`
            );
          }
        } else {
          results.errors.push("‚ùå Missing metadata or questions array");
          return results;
        }

        // Validate statistics
        if (data.statistics) {
          const easy = data.questions.filter(
            (q) => q.difficulty === "Easy"
          ).length;
          const medium = data.questions.filter(
            (q) => q.difficulty === "Medium"
          ).length;
          const hard = data.questions.filter(
            (q) => q.difficulty === "Hard"
          ).length;

          results.stats = { easy, medium, hard, total: data.questions.length };

          if (easy === data.statistics.easy) {
            results.success.push(`‚úÖ Easy count correct: ${easy}`);
          } else {
            results.errors.push(
              `‚ùå Easy count mismatch: declared ${data.statistics.easy}, found ${easy}`
            );
          }

          if (medium === data.statistics.medium) {
            results.success.push(`‚úÖ Medium count correct: ${medium}`);
          } else {
            results.errors.push(
              `‚ùå Medium count mismatch: declared ${data.statistics.medium}, found ${medium}`
            );
          }

          if (hard === data.statistics.hard) {
            results.success.push(`‚úÖ Hard count correct: ${hard}`);
          } else {
            results.errors.push(
              `‚ùå Hard count mismatch: declared ${data.statistics.hard}, found ${hard}`
            );
          }
        }

        // Validate each question
        const requiredFields = [
          "id",
          "title",
          "fileName",
          "difficulty",
          "topics",
          "summary",
          "keyApproach",
          "complexity",
        ];
        const seenIds = new Set();
        const seenTitles = new Set();

        data.questions.forEach((question, index) => {
          // Check for duplicate IDs
          if (seenIds.has(question.id)) {
            results.errors.push(`‚ùå Duplicate ID found: ${question.id}`);
          } else {
            seenIds.add(question.id);
          }

          // Check for duplicate titles
          if (seenTitles.has(question.title)) {
            results.warnings.push(`‚ö†Ô∏è Duplicate title: "${question.title}"`);
          } else {
            seenTitles.add(question.title);
          }

          // Check required fields
          const missingFields = requiredFields.filter(
            (field) => !question[field]
          );
          if (missingFields.length > 0) {
            results.errors.push(
              `‚ùå Question ${
                question.id || index + 1
              } missing fields: ${missingFields.join(", ")}`
            );
          }

          // Validate difficulty
          if (
            question.difficulty &&
            !["Easy", "Medium", "Hard"].includes(question.difficulty)
          ) {
            results.errors.push(
              `‚ùå Invalid difficulty for "${question.title}": ${question.difficulty}`
            );
          }

          // Validate complexity format
          if (question.complexity) {
            if (!question.complexity.time) {
              results.warnings.push(
                `‚ö†Ô∏è Missing time complexity for "${question.title}"`
              );
            }
            if (!question.complexity.space) {
              results.warnings.push(
                `‚ö†Ô∏è Missing space complexity for "${question.title}"`
              );
            }
          }

          // Validate topics array
          if (question.topics && !Array.isArray(question.topics)) {
            results.errors.push(
              `‚ùå Topics must be an array for "${question.title}"`
            );
          } else if (question.topics && question.topics.length === 0) {
            results.warnings.push(
              `‚ö†Ô∏è No topics specified for "${question.title}"`
            );
          }
        });

        // Validate indices
        if (data.topicIndex) {
          Object.entries(data.topicIndex).forEach(([topic, questionIds]) => {
            questionIds.forEach((id) => {
              const question = data.questions.find((q) => q.id === id);
              if (!question) {
                results.errors.push(
                  `‚ùå Topic index "${topic}" references non-existent question ID: ${id}`
                );
              } else if (!question.topics.some((t) => t.includes(topic))) {
                results.warnings.push(
                  `‚ö†Ô∏è Question "${question.title}" in topic index "${topic}" but topic not in question.topics`
                );
              }
            });
          });
        }

        if (data.difficultyIndex) {
          Object.entries(data.difficultyIndex).forEach(
            ([difficulty, questionIds]) => {
              questionIds.forEach((id) => {
                const question = data.questions.find((q) => q.id === id);
                if (!question) {
                  results.errors.push(
                    `‚ùå Difficulty index "${difficulty}" references non-existent question ID: ${id}`
                  );
                } else if (question.difficulty !== difficulty) {
                  results.errors.push(
                    `‚ùå Question "${question.title}" in "${difficulty}" index but has difficulty "${question.difficulty}"`
                  );
                }
              });
            }
          );
        }

        return results;
      }

      function displayResults(validation) {
        const resultsDiv = document.getElementById("results");

        let html = "<h2>Validation Results</h2>";

        // Display stats
        if (validation.stats) {
          html += '<div class="stats-grid">';
          html += `<div class="stat-card"><div class="stat-number">${validation.stats.total}</div><div class="stat-label">Total Questions</div></div>`;
          html += `<div class="stat-card"><div class="stat-number">${validation.stats.easy}</div><div class="stat-label">Easy</div></div>`;
          html += `<div class="stat-card"><div class="stat-number">${validation.stats.medium}</div><div class="stat-label">Medium</div></div>`;
          html += `<div class="stat-card"><div class="stat-number">${validation.stats.hard}</div><div class="stat-label">Hard</div></div>`;
          html += "</div>";
        }

        // Display errors
        if (validation.errors.length > 0) {
          html +=
            '<div class="status error"><strong>Errors Found:</strong></div>';
          html += "<ul>";
          validation.errors.forEach((error) => {
            html += `<li>${error}</li>`;
          });
          html += "</ul>";
        }

        // Display warnings
        if (validation.warnings.length > 0) {
          html +=
            '<div class="status warning"><strong>Warnings:</strong></div>';
          html += "<ul>";
          validation.warnings.forEach((warning) => {
            html += `<li>${warning}</li>`;
          });
          html += "</ul>";
        }

        // Display success messages
        if (validation.success.length > 0) {
          html +=
            '<div class="status success"><strong>Validations Passed:</strong></div>';
          html += "<ul>";
          validation.success.forEach((success) => {
            html += `<li>${success}</li>`;
          });
          html += "</ul>";
        }

        // Overall status
        if (
          validation.errors.length === 0 &&
          validation.warnings.length === 0
        ) {
          html =
            '<div class="status success">üéâ Perfect! All validations passed. Your repository is in great shape!</div>' +
            html;
        } else if (validation.errors.length === 0) {
          html =
            '<div class="status warning">‚ö†Ô∏è Validation passed with warnings. Consider addressing them.</div>' +
            html;
        } else {
          html =
            '<div class="status error">‚ùå Validation failed. Please fix the errors above.</div>' +
            html;
        }

        resultsDiv.innerHTML = html;
      }

      function generateReport() {
        if (!questionsData) {
          alert("Please run validation first!");
          return;
        }

        let report = "# DSA Repository Report\n\n";
        report += `**Generated:** ${new Date().toLocaleString()}\n\n`;
        report += `## Statistics\n\n`;
        report += `- Total Questions: ${questionsData.questions.length}\n`;
        report += `- Easy: ${questionsData.statistics.easy}\n`;
        report += `- Medium: ${questionsData.statistics.medium}\n`;
        report += `- Hard: ${questionsData.statistics.hard}\n\n`;

        report += `## Questions List\n\n`;
        questionsData.questions.forEach((q, i) => {
          report += `${i + 1}. **${q.title}** (${q.difficulty})\n`;
          report += `   - Topics: ${q.topics.join(", ")}\n`;
          report += `   - Time: ${q.complexity.time}, Space: ${q.complexity.space}\n\n`;
        });

        report += `## Topics Coverage\n\n`;
        if (questionsData.topicIndex) {
          Object.entries(questionsData.topicIndex).forEach(([topic, ids]) => {
            report += `- **${topic}**: ${ids.length} question(s)\n`;
          });
        }

        // Download report
        const blob = new Blob([report], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "repository-report.md";
        a.click();
        URL.revokeObjectURL(url);

        alert("Report generated and downloaded!");
      }

      // Auto-load on page load
      window.addEventListener("load", () => {
        loadAndValidate();
      });
    </script>
  </body>
</html>
