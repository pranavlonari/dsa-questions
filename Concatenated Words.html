<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Concatenated Words - DSA Questions</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.6;
        color: #24292e;
        background: #f6f8fa;
      }

      /* Navigation Bar */
      .nav-bar {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 1000;
      }

      .nav-brand {
        font-size: 1.5rem;
        font-weight: bold;
        text-decoration: none;
        color: white;
      }

      .nav-links {
        display: flex;
        gap: 1.5rem;
        align-items: center;
      }

      .nav-links a {
        color: white;
        text-decoration: none;
        padding: 0.5rem 1rem;
        border-radius: 5px;
        transition: background 0.3s;
      }

      .nav-links a:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      /* Container */
      .container {
        max-width: 1200px;
        margin: 2rem auto;
        padding: 0 2rem;
      }

      /* Header Section */
      .question-header {
        background: white;
        padding: 2rem;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        margin-bottom: 2rem;
      }

      .question-title {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 1rem;
        color: #1a202c;
      }

      .question-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        margin-bottom: 1rem;
      }

      .difficulty {
        display: inline-block;
        padding: 0.4rem 1rem;
        border-radius: 20px;
        font-weight: 600;
        font-size: 0.9rem;
      }

      .difficulty.easy {
        background: #d4edda;
        color: #155724;
      }

      .difficulty.medium {
        background: #fff3cd;
        color: #856404;
      }

      .difficulty.hard {
        background: #f8d7da;
        color: #721c24;
      }

      .topic-tag {
        display: inline-block;
        padding: 0.3rem 0.8rem;
        background: #e1e4e8;
        color: #586069;
        border-radius: 15px;
        font-size: 0.85rem;
        margin: 0.2rem;
      }

      /* Action Buttons */
      .action-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .btn {
        padding: 0.7rem 1.5rem;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      .btn-secondary {
        background: #e1e4e8;
        color: #24292e;
      }

      .btn-secondary:hover:not(:disabled) {
        background: #d1d5da;
      }

      .btn-success {
        background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
        color: white;
      }

      .btn-success:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(86, 171, 47, 0.4);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Navigation Buttons */
      .nav-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 2rem;
      }

      /* Content Section */
      .question-content {
        background: white;
        padding: 2rem;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }

      .question-content h1 {
        font-size: 1.8rem;
        margin-top: 2rem;
        margin-bottom: 1rem;
        color: #1a202c;
        border-bottom: 2px solid #e1e4e8;
        padding-bottom: 0.5rem;
      }

      .question-content h2 {
        font-size: 1.5rem;
        margin-top: 1.5rem;
        margin-bottom: 0.8rem;
        color: #2d3748;
      }

      .question-content h3 {
        font-size: 1.2rem;
        margin-top: 1.2rem;
        margin-bottom: 0.6rem;
        color: #4a5568;
      }

      .question-content p {
        margin-bottom: 1rem;
        color: #4a5568;
      }

      .question-content pre {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 1.5rem;
        border-radius: 8px;
        overflow-x: auto;
        margin: 1rem 0;
        line-height: 1.5;
      }

      .question-content code {
        background: #f6f8fa;
        color: #e83e8c;
        padding: 0.2rem 0.4rem;
        border-radius: 3px;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 0.9em;
      }

      .question-content pre code {
        background: transparent;
        color: inherit;
        padding: 0;
      }

      .question-content ul,
      .question-content ol {
        margin-left: 2rem;
        margin-bottom: 1rem;
      }

      .question-content li {
        margin-bottom: 0.5rem;
        color: #4a5568;
      }

      .question-content strong {
        color: #1a202c;
        font-weight: 600;
      }

      .question-content em {
        color: #718096;
      }

      /* Search Bar */
      .search-container {
        margin-bottom: 1.5rem;
      }

      .search-box {
        width: 100%;
        padding: 0.8rem 1rem;
        border: 2px solid #e1e4e8;
        border-radius: 8px;
        font-size: 1rem;
        transition: border-color 0.3s;
      }

      .search-box:focus {
        outline: none;
        border-color: #667eea;
      }

      /* Footer */
      .footer {
        text-align: center;
        padding: 2rem;
        color: #6c757d;
        margin-top: 3rem;
      }

      /* Responsive Design */
      @media (max-width: 1024px) {
        .container {
          max-width: 95%;
          padding: 0 1.5rem;
        }

        .question-title {
          font-size: 1.75rem;
        }

        .question-content h1 {
          font-size: 1.6rem;
        }
      }

      @media (max-width: 768px) {
        .nav-bar {
          flex-direction: column;
          gap: 1rem;
          padding: 1rem;
        }

        .nav-links {
          flex-wrap: wrap;
          justify-content: center;
          gap: 0.8rem;
        }

        .nav-links a {
          padding: 0.4rem 0.8rem;
          font-size: 0.9rem;
        }

        .question-header,
        .question-content {
          padding: 1.5rem;
        }

        .question-title {
          font-size: 1.5rem;
        }

        .question-meta {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.8rem;
        }

        .action-buttons,
        .nav-buttons {
          flex-direction: column;
        }

        .btn {
          width: 100%;
          justify-content: center;
        }

        .question-content h1 {
          font-size: 1.4rem;
        }

        .question-content h2 {
          font-size: 1.2rem;
        }

        .question-content h3 {
          font-size: 1.1rem;
        }

        .question-content pre {
          padding: 1rem;
          font-size: 0.85rem;
        }
      }

      @media (max-width: 480px) {
        .container {
          margin: 1rem auto;
          padding: 0 1rem;
        }

        .nav-brand {
          font-size: 1.2rem;
        }

        .question-header,
        .question-content {
          padding: 1rem;
          border-radius: 8px;
        }

        .question-title {
          font-size: 1.3rem;
        }

        .btn {
          padding: 0.6rem 1rem;
          font-size: 0.9rem;
        }

        .difficulty,
        .topic-tag {
          font-size: 0.8rem;
          padding: 0.3rem 0.6rem;
        }

        .question-content pre {
          font-size: 0.8rem;
          padding: 0.8rem;
        }
      }

      /* Toast notification */
      .toast {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background: #28a745;
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s;
        z-index: 2000;
      }

      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }

      @media (max-width: 480px) {
        .toast {
          bottom: 1rem;
          right: 1rem;
          left: 1rem;
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <!-- Navigation Bar -->
    <nav class="nav-bar">
      <a href="index.html" class="nav-brand">üß† DSA Questions</a>
      <div class="nav-links">
        <a href="index.html">üè† Home</a>
        <a href="https://github.com/pranavlonari/dsa-questions" target="_blank"
          >üìÅ GitHub</a
        >
      </div>
    </nav>

    <div class="container">
      <!-- Search Bar -->
      <div class="search-container">
        <input
          type="text"
          id="searchBox"
          class="search-box"
          placeholder="üîç Search questions..."
        />
      </div>

      <!-- Navigation Buttons -->
      <div class="nav-buttons">
        <button
          id="prevBtn"
          class="btn btn-secondary"
          onclick="navigateToPrev()"
        >
          ‚Üê Previous
        </button>
        <button
          id="nextBtn"
          class="btn btn-secondary"
          onclick="navigateToNext()"
        >
          Next ‚Üí
        </button>
        <button class="btn btn-primary" onclick="navigateToRandom()">
          üé≤ Random Question
        </button>
      </div>

      <!-- Question Header -->
      <div class="question-header">
        <h1 class="question-title">Concatenated Words</h1>

        <div class="question-meta">
          <span class="difficulty medium">Medium</span>
          <div class="topics">
            <span class="topic-tag">Hash Table</span><span class="topic-tag">Array</span><span class="topic-tag">String</span><span class="topic-tag">Dynamic Programming</span><span class="topic-tag">DP</span>
          </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
          <button class="btn btn-success" onclick="copyCode()">
            üìã Copy Code
          </button>
          <button class="btn btn-secondary" onclick="exportToMarkdown()">
            üì• Export MD
          </button>
          <button class="btn btn-primary" onclick="shareQuestion()">
            üîó Share
          </button>
        </div>
      </div>

      <!-- Question Content -->
      <div class="question-content"><p>Concatenated Words</p>

<p>Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.</p>

<p>A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.</p>

<p>Example 1:</p>

<p>Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";
"dogcatsdog" can be concatenated by "dog", "cats" and "dog";
"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
Example 2:</p>

<p>Input: words = ["cat","dog","catdog"]
Output: ["catdog"]</p>

<p>Constraints:</p>

<p>1 <= words.length <= 10^4
1 <= words[i].length <= 30
words[i] consists of only lowercase English letters.
All the strings of words are unique.
1 <= sum(words[i].length) <= 10^5</p>

<h1>Short script to say to the interviewer</h1>

<p>‚ÄúSort the words by length and maintain a set of words we've seen so far (only shorter or equal length). For each word, use DP to check if it can be formed by concatenating two or more words from the set. If it can, add it to the answer; otherwise insert it into the set and continue. Sorting by length ensures we only use smaller words to build larger ones and avoids using the word itself.‚Äù</p>

<h1>Intuition</h1>

<p>A word is concatenated if you can split it into pieces where each piece is a word in the dictionary. For each word we can do a <code>dp[i]</code> boolean where <code>dp[i]</code> means prefix <code>word[0..i)</code> can be formed. <code>dp[0] = true</code>. For each <code>i</code> with <code>dp[i] == true</code> try every <code>j > i</code> and if <code>word[i..j)</code> is in the set mark <code>dp[j] = true</code>. At the end <code>dp[len]</code> tells us if the full word can be formed. We only check against words already in the set (shorter/equal words processed earlier) ‚Äî so we must process in increasing length order.</p>

<h1>Complexity</h1>

<ul>
<li>Let <code>n = words.length</code>, <code>L</code> = max word length (‚â§ 30).</li>
<li>Sorting by length: <code>O(n log n)</code>.</li>
<li>For each word we run DP with nested loops that check substrings in <code>O(L^2)</code> time, but substring lookups are <code>O(L)</code> if you slice, so overall <code>O(n <em> L^2)</code> or <code>O(n </em> L^2)</code> with optimizations. Given <code>L ‚â§ 30</code>, this is fast in practice.</li>
<li>Space: <code>O(sum lengths)</code> for the set and DP arrays.</li>
</ul>

<h1>Java implementation</h1>

<p><pre><code>import java.util.*;

public class Solution {
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        List<String> ans = new ArrayList<>();
        if (words == null || words.length == 0) return ans;

        // Sort words by length ascending
        Arrays.sort(words, Comparator.comparingInt(String::length));

        Set<String> built = new HashSet<>();

        for (String word : words) {
            if (word.length() == 0) continue;

            if (canForm(word, built)) {
                ans.add(word);
            }
            // Whether it was concatenated or not, add it to set so longer words can use it
            built.add(word);
        }
        return ans;
    }

    // Check if word can be formed by concatenating words from 'dict' (dict contains only previously processed words)
    private boolean canForm(String word, Set<String> dict) {
        if (dict.isEmpty()) return false; // no smaller words to form this yet

        int n = word.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;

        for (int i = 0; i < n; i++) {
            if (!dp[i]) continue;
            // try all next split positions
            for (int j = i + 1; j <= n; j++) {
                // If substring word[i:j) is in dict, mark dp[j]
                if (!dp[j] && dict.contains(word.substring(i, j))) {
                    dp[j] = true;
                }
                // early stop if we already can form entire word
                if (dp[n]) return true;
            }
        }
        return dp[n];
    }

    // quick test
    public static void main(String[] args) {
        Solution sol = new Solution();

        String[] words1 = {"cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"};
        System.out.println(sol.findAllConcatenatedWordsInADict(words1));
        // expected: ["catsdogcats","dogcatsdog","ratcatdogcat"] (order may vary)

        String[] words2 = {"cat","dog","catdog"};
        System.out.println(sol.findAllConcatenatedWordsInADict(words2));
        // expected: ["catdog"]
    }
}</code></pre></p>

<h1>Notes & small optimizations</h1>

<ul>
<li>The implementation uses <code>String.substring(i,j)</code> which takes O(L) to create a new string; given L ‚â§ 30 this is fine. If you needed micro-optimizations you could avoid substring creation by using a Trie or rolling-hash lookups.</li>
<li>Sorting by length is crucial. Without it you might attempt to form a word using itself.</li>
<li>This approach naturally handles repeated building using the same smaller word multiple times (e.g., <code>"catcat"</code>).</li>
</ul></div>
    </div>

    <!-- Footer -->
    <div class="footer">
      <p>
        Made with ‚ù§Ô∏è for Interview Preparation |
        <a
          href="https://github.com/pranavlonari/dsa-questions"
          style="color: #667eea"
          >Contribute on GitHub</a
        >
      </p>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <script>
      // Load questions data
      let questionsData = [];
      let currentQuestionIndex = -1;

      // Load questions.json
      fetch("questions.json")
        .then((response) => response.json())
        .then((data) => {
          questionsData = data.questions;
          initializePage();
        })
        .catch((error) => {
          console.error("Error loading questions:", error);
        });

      function initializePage() {
        // Get current question filename from URL
        const fileName = getCurrentFileName();

        // Find current question index
        currentQuestionIndex = questionsData.findIndex(
          (q) => q.fileName === fileName
        );

        // Update navigation buttons
        updateNavigationButtons();
      }

      function getCurrentFileName() {
        // Get the current HTML filename without extension
        const path = window.location.pathname;
        const filename = path.split("/").pop();
        // Remove .html extension to match with fileName in questions.json
        return filename.replace(".html", "");
      }

      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");

        if (currentQuestionIndex <= 0) {
          prevBtn.disabled = true;
        } else {
          prevBtn.disabled = false;
        }

        if (
          currentQuestionIndex >= questionsData.length - 1 ||
          currentQuestionIndex === -1
        ) {
          nextBtn.disabled = true;
        } else {
          nextBtn.disabled = false;
        }
      }

      function navigateToPrev() {
        if (currentQuestionIndex > 0) {
          const prevQuestion = questionsData[currentQuestionIndex - 1];
          window.location.href = `${prevQuestion.fileName}.html`;
        }
      }

      function navigateToNext() {
        if (
          currentQuestionIndex < questionsData.length - 1 &&
          currentQuestionIndex !== -1
        ) {
          const nextQuestion = questionsData[currentQuestionIndex + 1];
          window.location.href = `${nextQuestion.fileName}.html`;
        }
      }

      function navigateToRandom() {
        const randomIndex = Math.floor(Math.random() * questionsData.length);
        const randomQuestion = questionsData[randomIndex];
        window.location.href = `${randomQuestion.fileName}.html`;
      }

      // Search functionality
      document
        .getElementById("searchBox")
        .addEventListener("input", function (e) {
          const searchTerm = e.target.value.toLowerCase();
          if (searchTerm.length < 2) return;

          const results = questionsData.filter(
            (q) =>
              q.title.toLowerCase().includes(searchTerm) ||
              q.topics.some((t) => t.toLowerCase().includes(searchTerm))
          );

          if (results.length > 0 && e.key === "Enter") {
            window.location.href = `${results[0].fileName}.html`;
          }
        });

      document
        .getElementById("searchBox")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            const searchTerm = e.target.value.toLowerCase();
            const results = questionsData.filter(
              (q) =>
                q.title.toLowerCase().includes(searchTerm) ||
                q.topics.some((t) => t.toLowerCase().includes(searchTerm))
            );

            if (results.length > 0) {
              window.location.href = `${results[0].fileName}.html`;
            } else {
              showToast("No questions found!");
            }
          }
        });

      // Copy code functionality
      function copyCode() {
        const codeBlocks = document.querySelectorAll("pre code");
        if (codeBlocks.length === 0) {
          showToast("No code found to copy!");
          return;
        }

        let allCode = "";
        codeBlocks.forEach((block, index) => {
          if (index > 0) allCode += "\n\n";
          allCode += block.textContent;
        });

        navigator.clipboard
          .writeText(allCode)
          .then(() => {
            showToast("‚úÖ Code copied to clipboard!");
          })
          .catch((err) => {
            showToast("‚ùå Failed to copy code");
            console.error("Copy failed:", err);
          });
      }

      // Export to markdown
      function exportToMarkdown() {
        const title = document.querySelector(".question-title").textContent;
        const content = document.querySelector(".question-content").innerText;

        const markdown = `# ${title}\n\n${content}`;

        const blob = new Blob([markdown], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${title.replace(/[^a-z0-9]/gi, "-").toLowerCase()}.md`;
        a.click();
        URL.revokeObjectURL(url);

        showToast("üì• Markdown file downloaded!");
      }

      // Share question
      function shareQuestion() {
        const title = document.querySelector(".question-title").textContent;
        const url = window.location.href;

        if (navigator.share) {
          navigator
            .share({
              title: title,
              text: `Check out this DSA question: ${title}`,
              url: url,
            })
            .then(() => {
              showToast("‚úÖ Shared successfully!");
            })
            .catch((err) => {
              console.log("Share failed:", err);
              copyUrlToClipboard(url);
            });
        } else {
          copyUrlToClipboard(url);
        }
      }

      function copyUrlToClipboard(url) {
        navigator.clipboard
          .writeText(url)
          .then(() => {
            showToast("üîó Link copied to clipboard!");
          })
          .catch((err) => {
            showToast("‚ùå Failed to copy link");
            console.error("Copy failed:", err);
          });
      }

      // Toast notification
      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.add("show");

        setTimeout(() => {
          toast.classList.remove("show");
        }, 3000);
      }
    </script>
  </body>
</html>
