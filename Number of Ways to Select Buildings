Number of Ways to Select Buildings  
Example 1:

Input: s = "001101"
Output: 6
Explanation:
The following sets of indices selected are valid:

- [0,2,4] from "001101" forms "010"
- [0,3,4] from "001101" forms "010"
- [1,2,4] from "001101" forms "010"
- [1,3,4] from "001101" forms "010"
- [2,4,5] from "001101" forms "101"
- [3,4,5] from "001101" forms "101"
  No other selection is valid. Thus, there are 6 total ways.
  Example 2:

Input: s = "11100"
Output: 0
Explanation: It can be shown that there are no valid selections.

Constraints:

3 <= s.length <= 10^5
s[i] is either '0' or '1'.

class Solution {
public long numberOfWays(String s) {

    }

}

Great — let’s go deep and detailed.

I'll explain the **intuition**, give a **mathematically clean derivation**, show the **O(n)** algorithm (with code), prove correctness, analyze complexity, walk through an example step-by-step, discuss edge cases, and mention alternative approaches.

---

## Problem intuition (short)

We need the number of length-3 subsequences (i < j < k) of the string `s` that form either `"010"` or `"101"`. Count each occurrence separately (subsequences, not substrings).

A convenient way is to count contributions of every index `j` as the middle of a 3-length subsequence:

- If `s[j] == '0'`, it can be the middle of `"101"`; the number of such subsequences with center `j` equals:

  ```
  (# of '1's to the left of j) * (# of '1's to the right of j)
  ```

- If `s[j] == '1'`, it can be the middle of `"010"`; the number equals:

  ```
  (# of '0's to the left of j) * (# of '0's to the right of j)
  ```

So the total answer is the sum of these contributions for all positions `j`.

Why this works: to pick a subsequence of the form `"101"` with center at `j`, we must choose any `'1'` index left of `j` and any `'1'` index right of `j`. The number of choices is exactly the product of counts on both sides. Same for `"010"`.

---

## Algorithm (O(n) time, O(1) extra space)

1. First count `totalZeros` and `totalOnes` in `s`.
2. Maintain running `leftZeros = 0` and `leftOnes = 0` while iterating positions `j` from left to right.
3. For each position `j`:

   - If `s[j] == '0'`: contribution = `leftOnes * (totalOnes - leftOnes)`.
   - If `s[j] == '1'`: contribution = `leftZeros * (totalZeros - leftZeros)`.
   - Add contribution to answer (use `long`).
   - Then update `leftZeros` or `leftOnes` by 1 (to include `s[j]` for future indices).

4. Return the accumulated answer.

We compute the contribution using counts **before** incrementing the left counters, because `left*right` counts refer to elements strictly on left / right of `j`.

---

## Correctness

For each `j`, the formulas count all combinations of `i < j < k` where the characters at i and k make the desired pattern with `s[j]` as the center. Every valid subsequence has a unique center index `j`, so we count each subsequence exactly once. Thus summing contributions over `j` yields the correct total.

---

## Complexity

- Time: `O(n)` single pass (after initial total count).
- Space: `O(1)` extra (just counters and the final `long`).
- Use `long` for the answer because counts multiply and `n` up to 1e5 → worst-case answer up to ~ (1e5)^2 which is > 32-bit.

---

## Java implementation

```java
class Solution {
    public long numberOfWays(String s) {
        int n = s.length();
        long totalZeros = 0;
        long totalOnes = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '0') totalZeros++;
            else totalOnes++;
        }

        long leftZeros = 0;
        long leftOnes = 0;
        long ans = 0;

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c == '0') {
                // '0' as center of "101"
                long rightOnes = totalOnes - leftOnes; // ones strictly to the right
                ans += leftOnes * rightOnes;
                leftZeros++;
            } else { // c == '1'
                // '1' as center of "010"
                long rightZeros = totalZeros - leftZeros; // zeros strictly to the right
                ans += leftZeros * rightZeros;
                leftOnes++;
            }
        }
        return ans;
    }

    // quick local test
    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.numberOfWays("001101")); // 6
        System.out.println(sol.numberOfWays("11100"));  // 0
        System.out.println(sol.numberOfWays("01010"));  // example: verify manually
    }
}
```

---

## Walk-through example: `s = "001101"`

- `totalZeros = 3`, `totalOnes = 3`.
- i=0, c='0': leftOnes=0 → add 0\*(3-0)=0 ; leftZeros=1
- i=1, c='0': leftOnes=0 → add 0 ; leftZeros=2
- i=2, c='1': leftZeros=2 → add 2\*(3-2)=2 ; leftOnes=1
- i=3, c='1': leftZeros=2 → add 2\*(3-2)=2 ; leftOnes=2
- i=4, c='0': leftOnes=2 → add 2\*(3-2)=2 ; leftZeros=3
- i=5, c='1': leftZeros=3 → add 3\*(3-3)=0 ; leftOnes=3
  Total = 0+0+2+2+2+0 = 6 ✅

Matches expected output.

---

## Edge cases

- If the string length < 3 → answer is 0 (the algorithm still returns 0).
- If `abs(totalZeros - totalOnes) > n` irrelevant — the algorithm handles all.
- Strings with no `'0'` or no `'1'` → contributions always zero → returns 0.
- Works for large `n` up to 10^5; uses `long` to avoid overflow.

---

## Alternative viewpoints / other methods

- You can compute prefix arrays `prefixZeros[i]` / `prefixOnes[i]` and for each `j` compute contribution using `prefix` and `suffix` values. That's the same idea but with arrays; the rolling counters above are more memory efficient and simpler.
- Brute force triple loop `O(n^3)` or two loops checking pairs `O(n^2)` are too slow for 1e5.
- There is no need for combinatorics beyond these simple products per center.

---
