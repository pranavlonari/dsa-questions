{
  "metadata": {
    "repository": "DSA Questions Collection",
    "description": "Interview-ready solutions with detailed explanations",
    "lastUpdated": "2025-11-12",
    "totalQuestions": 37
  },
  "statistics": {
    "easy": 0,
    "medium": 37,
    "hard": 0
  },
  "questions": [
    {
      "id": 1,
      "title": "All Nodes Distance K in Binary Tree",
      "fileName": "All Nodes Distance K in Binary Tree",
      "difficulty": "Medium",
      "topics": [
        "Binary Tree",
        "Tree",
        "BFS",
        "DFS",
        "Graph"
      ],
      "summary": "restatement",
      "keyApproach": "1. DFS (or iterative traversal) to fill `parent` pointers and also find the `targetNode` matching the given `target` value.",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 2,
      "title": "Concatenated Words",
      "fileName": "Concatenated Words",
      "difficulty": "Medium",
      "topics": [
        "Hash Table",
        "Array",
        "String",
        "Dynamic Programming",
        "DP"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 3,
      "title": "Copy List with Random Pointer",
      "fileName": "Copy List with Random Pointer",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Linked List",
        "Hash Table",
        "Two Pointers"
      ],
      "summary": "statement: Given the head of a linked list where each node has an extra `random` pointer that can point to any node in the list or `null`, return a **deep copy** of the list. The deep copy should dupl...",
      "keyApproach": "1. **Weave copies**: For each original node `cur`, create `copy = new Node(cur.val)` and insert it after `cur` (`cur.next = copy; copy.next = nextOrig",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 4,
      "title": "Count Unique Characters of All Substrings of a Given String",
      "fileName": "Count Unique Characters of All Substrings of a Given String",
      "difficulty": "Medium",
      "topics": [
        "Hash Table",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "guarantees 32-bit fit).",
      "keyApproach": "",
      "complexity": {
        "time": "O(n + A)",
        "space": "O(n)"
      }
    },
    {
      "id": 5,
      "title": "Course Schedule",
      "fileName": "Course Schedule",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "DFS",
        "Graph",
        "Array",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 6,
      "title": "Design Parking System",
      "fileName": "Design Parking System",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 7,
      "title": "Find Good Days to Rob the Bank",
      "fileName": "Find Good Days to Rob the Bank",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Two Pointers",
        "Sliding Window"
      ],
      "summary": "restatement (short)",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 8,
      "title": "Find K-th Smallest Pair Distance",
      "fileName": "Find K-th Smallest Pair Distance",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Two Pointers",
        "Sorting"
      ],
      "summary": "",
      "keyApproach": "- Sort `nums`.",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 9,
      "title": "find Median from Data Stream",
      "fileName": "find Median from Data Stream",
      "difficulty": "Medium",
      "topics": [
        "Tree",
        "BFS",
        "Graph",
        "Hash Table",
        "Array"
      ],
      "summary": ". Below is an interview-ready answer you can speak to the interviewer, plus a clean Java implementation (two-heap approach), complexity, tests, and answers to the two follow-up questions.",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 10,
      "title": "Find the K-Sum of an Array",
      "fileName": "Find the K-Sum of an Array",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Array",
        "String",
        "Greedy",
        "Heap"
      ],
      "summary": "definition examples.",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 11,
      "title": "Group Anagrams",
      "fileName": "Group Anagrams",
      "difficulty": "Medium",
      "topics": [
        "Hash Table",
        "Array",
        "String",
        "Sorting"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 12,
      "title": "Integer to English Words",
      "fileName": "Integer to English Words",
      "difficulty": "Medium",
      "topics": [
        "DFS",
        "Graph",
        "Array",
        "String",
        "Stack"
      ],
      "summary": "restatement",
      "keyApproach": "1. **Handle zero:** If `num == 0`, return `\"Zero\"`.",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 13,
      "title": "K Closest Points to Origin",
      "fileName": "K Closest Points to Origin",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "DFS",
        "Array",
        "Greedy",
        "Heap"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "time O(n log k)",
        "space": "space O(k)"
      }
    },
    {
      "id": 14,
      "title": "LRU Cache",
      "fileName": "LRU Cache",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "Linked List",
        "Hash Table",
        "Array"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 15,
      "title": "Maximum Length of Subarray With Positive Product",
      "fileName": "Maximum Length of Subarray With Positive Product",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 16,
      "title": "Maximum Number of Robots Within Budget",
      "fileName": "Maximum Number of Robots Within Budget",
      "difficulty": "Medium",
      "topics": [
        "Tree",
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "restatement Given two arrays `chargeTimes` and `runningCosts` of length `n` and a `budget`, find the maximum length of a contiguous subarray (consecutive robots) such that:",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 17,
      "title": "Maximum Units on a Truck",
      "fileName": "Maximum Units on a Truck",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Greedy",
        "Sorting"
      ],
      "summary": "restatement (short):** You have several box types described as `[count, unitsPerBox]`. You can load at most `truckSize` boxes. Choose boxes to maximize total units loaded. Return that maximum.",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 18,
      "title": "Minimum Number of Moves to Make Palindrome",
      "fileName": "Minimum Number of Moves to Make Palindrome",
      "difficulty": "Medium",
      "topics": [
        "Tree",
        "Array",
        "String",
        "Greedy",
        "Two Pointers"
      ],
      "summary": ". Below is an interview-ready answer you can say to the interviewer, followed by a clear, correct Java implementation (greedy simulation), complexity, tests, and a short note about a faster alternativ...",
      "keyApproach": "",
      "complexity": {
        "time": "O(n²)",
        "space": "O(n)"
      }
    },
    {
      "id": 19,
      "title": "Minimum Number of Swaps to Make the Binary String Alternating",
      "fileName": "Minimum Number of Swaps to Make the Binary String Alternating",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 20,
      "title": "Number of Islands",
      "fileName": "Number of Islands",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "DFS",
        "Graph",
        "Array",
        "String"
      ],
      "summary": ".",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 21,
      "title": "Number of Ways to Select Buildings",
      "fileName": "Number of Ways to Select Buildings",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 22,
      "title": "Plates Between Candles",
      "fileName": "Plates Between Candles",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 23,
      "title": "Race Car",
      "fileName": "Race Car",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Hash Table",
        "String",
        "Dynamic Programming",
        "DP"
      ],
      "summary": "(LeetCode 818). I'll explain a neat dynamic-programming / greedy solution (memoized recursion) that runs very fast for `target ≤ 10^4`, then give a clean Java implementation you can use in an intervie...",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      },
      "leetcodeNumber": 818
    },
    {
      "id": 24,
      "title": "Reorder Data in Log Files",
      "fileName": "Reorder Data in Log Files",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Sorting"
      ],
      "summary": ". The simplest, clearest approach for an interview is:",
      "keyApproach": "",
      "complexity": {
        "time": "O(n log n · k)",
        "space": "O(n)"
      }
    },
    {
      "id": 25,
      "title": "Reorganize String",
      "fileName": "Reorganize String",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "DFS",
        "Graph",
        "Array",
        "String"
      ],
      "summary": "restatement: Given a string `s`, rearrange its characters so that no two adjacent characters are the same. Return any valid rearrangement or return `\"\"` if it's impossible.",
      "keyApproach": "1. Count frequencies of characters. Let `n = s.length()`. If any `freq[i] > (n+1)/2` return `\"\"`.",
      "complexity": {
        "time": "O(n log k)",
        "space": "O(k)"
      }
    },
    {
      "id": 26,
      "title": "Rotting Oranges",
      "fileName": "Rotting Oranges",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "restatement**",
      "keyApproach": "1. Initialize queue with all `2`s (rotten), and count all `1`s (fresh).",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 27,
      "title": "Search Suggestions System",
      "fileName": "Search Suggestions System",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Sorting",
        "Binary Search"
      ],
      "summary": ". The easiest, clean, and interview-friendly solution is:",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 28,
      "title": "Sequential Digits",
      "fileName": "Sequential Digits",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Array",
        "String",
        "Dynamic Programming",
        "DP"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 29,
      "title": "Sequentially Ordinal Rank Tracker",
      "fileName": "Sequentially Ordinal Rank Tracker",
      "difficulty": "Medium",
      "topics": [
        "Tree",
        "BFS",
        "Graph",
        "String",
        "Greedy"
      ],
      "summary": ". .",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 30,
      "title": "Sliding Window Maximum",
      "fileName": "Sliding Window Maximum",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "Two Pointers",
        "Sliding Window",
        "Queue"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(k)"
      }
    },
    {
      "id": 31,
      "title": "Substring With Largest Variance",
      "fileName": "Substring With Largest Variance",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 32,
      "title": "Sum of Subarray Ranges",
      "fileName": "Sum of Subarray Ranges",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers",
        "Stack",
        "Queue"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 33,
      "title": "Sum of Total Strength of Wizards",
      "fileName": "Sum of Total Strength of Wizards",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers",
        "Stack",
        "Queue"
      ],
      "summary": "recap (one line)",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 34,
      "title": "Total Appeal of A String",
      "fileName": "Total Appeal of A String",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": ". Quick answer: scan once and for each character at index `i` add `(i - lastPos[c]) * (n - i)` to the total, where `lastPos[c]` is the previous index where that character appeared (or `-1` if none). T...",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 35,
      "title": "Trapping Rain Water",
      "fileName": "Trapping Rain Water",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers",
        "Stack"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 36,
      "title": "Word Break II",
      "fileName": "Word Break II",
      "difficulty": "Medium",
      "topics": [
        "DFS",
        "Graph",
        "Hash Table",
        "Array",
        "String"
      ],
      "summary": "restatement",
      "keyApproach": "1. Build `dict` from `wordDict` and compute `canBreak` boolean DP from back to front:",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 37,
      "title": "Word Ladder",
      "fileName": "Word Ladder",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "Hash Table",
        "Array",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(N)"
      }
    }
  ],
  "topicIndex": {
    "Binary Tree": [
      1
    ],
    "Tree": [
      1,
      9,
      16,
      18,
      29
    ],
    "BFS": [
      1,
      5,
      9,
      10,
      13,
      14,
      20,
      23,
      25,
      26,
      28,
      29,
      37
    ],
    "DFS": [
      1,
      5,
      12,
      13,
      20,
      25,
      36
    ],
    "Graph": [
      1,
      3,
      5,
      6,
      7,
      8,
      9,
      12,
      14,
      15,
      16,
      17,
      20,
      21,
      24,
      25,
      26,
      27,
      29,
      30,
      34,
      36,
      37
    ],
    "Hash Table": [
      2,
      3,
      4,
      9,
      11,
      14,
      23,
      36,
      37
    ],
    "Array": [
      2,
      4,
      5,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      24,
      25,
      26,
      27,
      28,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37
    ],
    "String": [
      2,
      4,
      5,
      6,
      7,
      8,
      10,
      11,
      12,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      31,
      32,
      33,
      34,
      35,
      36,
      37
    ],
    "Dynamic Programming": [
      2,
      23,
      28
    ],
    "DP": [
      2,
      23,
      28
    ],
    "Linked List": [
      3,
      14
    ],
    "Two Pointers": [
      3,
      4,
      7,
      8,
      15,
      16,
      18,
      21,
      22,
      26,
      30,
      31,
      32,
      33,
      34,
      35
    ],
    "Sliding Window": [
      7,
      30
    ],
    "Sorting": [
      8,
      11,
      17,
      24,
      27
    ],
    "Greedy": [
      10,
      13,
      17,
      18,
      29
    ],
    "Heap": [
      10,
      13
    ],
    "Stack": [
      12,
      32,
      33,
      35
    ],
    "Binary Search": [
      27
    ],
    "Queue": [
      30,
      32,
      33
    ]
  },
  "difficultyIndex": {
    "Easy": [],
    "Medium": [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37
    ],
    "Hard": []
  },
  "instructions": {
    "addingNewQuestion": "Simply add a new question file to the repository and run `python generate.py` to automatically update all files.",
    "requiredFields": [
      "id",
      "title",
      "fileName",
      "difficulty",
      "topics",
      "summary",
      "keyApproach",
      "complexity"
    ],
    "optionalFields": [
      "companies",
      "leetcodeNumber",
      "approaches",
      "tags"
    ]
  }
}