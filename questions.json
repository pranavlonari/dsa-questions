{
  "metadata": {
    "repository": "DSA Questions Collection",
    "description": "Interview-ready solutions with detailed explanations",
    "lastUpdated": "2025-11-13",
    "totalQuestions": 37
  },
  "statistics": {
    "easy": 0,
    "medium": 37,
    "hard": 0
  },
  "questions": [
    {
      "id": 1,
      "title": "All Nodes Distance K in Binary Tree",
      "fileName": "All Nodes Distance K in Binary Tree",
      "difficulty": "Medium",
      "topics": [
        "Binary Tree",
        "Tree",
        "BFS",
        "DFS",
        "Graph"
      ],
      "summary": "restatement",
      "keyApproach": "1. DFS (or iterative traversal) to fill `parent` pointers and also find the `targetNode` matching the given `target` value.",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 2,
      "title": "Concatenated Words",
      "fileName": "Concatenated Words",
      "difficulty": "Medium",
      "topics": [
        "Hash Table",
        "Array",
        "String",
        "Dynamic Programming",
        "DP"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 3,
      "title": "Copy List with Random Pointer",
      "fileName": "Copy List with Random Pointer",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Linked List",
        "Hash Table",
        "Two Pointers"
      ],
      "summary": "statement: Given the head of a linked list where each node has an extra `random` pointer that can point to any node in the list or `null`, return a **deep copy** of the list. The deep copy should dupl...",
      "keyApproach": "1. **Weave copies**: For each original node `cur`, create `copy = new Node(cur.val)` and insert it after `cur` (`cur.next = copy; copy.next = nextOrig",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 4,
      "title": "Count Unique Characters of All Substrings of a Given String",
      "fileName": "Count Unique Characters of All Substrings of a Given String",
      "difficulty": "Medium",
      "topics": [
        "Hash Table",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "guarantees 32-bit fit).",
      "keyApproach": "",
      "complexity": {
        "time": "O(n + A)",
        "space": "O(n)"
      }
    },
    {
      "id": 5,
      "title": "Course Schedule",
      "fileName": "Course Schedule",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "DFS",
        "Graph",
        "Array",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 6,
      "title": "Design Parking System",
      "fileName": "Design Parking System",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 7,
      "title": "Find Good Days to Rob the Bank",
      "fileName": "Find Good Days to Rob the Bank",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers",
        "Sliding Window"
      ],
      "summary": "",
      "keyApproach": "1. If `time == 0` return all indices immediately.",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 8,
      "title": "Find K-th Smallest Pair Distance",
      "fileName": "Find K-th Smallest Pair Distance",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Two Pointers",
        "Sorting"
      ],
      "summary": "",
      "keyApproach": "- Sort `nums`.",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 9,
      "title": "find Median from Data Stream",
      "fileName": "find Median from Data Stream",
      "difficulty": "Medium",
      "topics": [
        "Tree",
        "BFS",
        "Array",
        "Greedy",
        "Heap"
      ],
      "summary": ". The standard, simple, and interview-friendly solution is **two heaps**:",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 10,
      "title": "Find the K-Sum of an Array",
      "fileName": "Find the K-Sum of an Array",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Array",
        "Greedy",
        "Heap",
        "Queue"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 11,
      "title": "Group Anagrams",
      "fileName": "Group Anagrams",
      "difficulty": "Medium",
      "topics": [
        "Hash Table",
        "Array",
        "String",
        "Sorting"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 12,
      "title": "Integer to English Words",
      "fileName": "Integer to English Words",
      "difficulty": "Medium",
      "topics": [
        "DFS",
        "String"
      ],
      "summary": "restatement",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 13,
      "title": "K Closest Points to Origin",
      "fileName": "K Closest Points to Origin",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "DFS",
        "Array",
        "Greedy",
        "Heap"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "time O(n log k)",
        "space": "space O(k)"
      }
    },
    {
      "id": 14,
      "title": "LRU Cache",
      "fileName": "LRU Cache",
      "difficulty": "Medium",
      "topics": [
        "Linked List",
        "Hash Table",
        "Two Pointers"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 15,
      "title": "Maximum Length of Subarray With Positive Product",
      "fileName": "Maximum Length of Subarray With Positive Product",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 16,
      "title": "Maximum Number of Robots Within Budget",
      "fileName": "Maximum Number of Robots Within Budget",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers",
        "Sliding Window",
        "Queue"
      ],
      "summary": "restatement Given two arrays `chargeTimes` and `runningCosts` of length `n` and a `budget`, find the maximum length of a contiguous subarray (consecutive robots) such that:",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 17,
      "title": "Maximum Units on a Truck",
      "fileName": "Maximum Units on a Truck",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Greedy",
        "Sorting"
      ],
      "summary": "restatement (short):** You have several box types described as `[count, unitsPerBox]`. You can load at most `truckSize` boxes. Choose boxes to maximize total units loaded. Return that maximum.",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 18,
      "title": "Minimum Number of Moves to Make Palindrome",
      "fileName": "Minimum Number of Moves to Make Palindrome",
      "difficulty": "Medium",
      "topics": [
        "Tree",
        "BFS",
        "Graph",
        "Array",
        "String"
      ],
      "summary": "recap (one line)",
      "keyApproach": "1. Build a target palindrome string `t` of same multiset of characters as `s`. How? For each character `c`, let `cnt[c]`. Put `cnt[c]/2` copies into t",
      "complexity": {
        "time": "O(n²)",
        "space": "O(n)"
      }
    },
    {
      "id": 19,
      "title": "Minimum Number of Swaps to Make the Binary String Alternating",
      "fileName": "Minimum Number of Swaps to Make the Binary String Alternating",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "id": 20,
      "title": "Number of Islands",
      "fileName": "Number of Islands",
      "difficulty": "Medium",
      "topics": [
        "Tree",
        "BFS",
        "DFS",
        "Graph",
        "Hash Table"
      ],
      "summary": ".",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 21,
      "title": "Number of Ways to Select Buildings",
      "fileName": "Number of Ways to Select Buildings",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "intuition (short)",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 22,
      "title": "Plates Between Candles",
      "fileName": "Plates Between Candles",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Two Pointers",
        "Sorting"
      ],
      "summary": ", give the clean, optimal algorithm and a correctness argument, show a step-by-step worked example, discuss edge cases and complexity, and finally provide a polished Java implementation you can paste ...",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 23,
      "title": "Race Car",
      "fileName": "Race Car",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Array",
        "Dynamic Programming",
        "DP"
      ],
      "summary": "— classic LeetCode **Race Car** (818). I'll give a full, detailed explanation of the idea, the cases to consider, correctness intuition, complexity, and a clean Java dynamic programming implementation...",
      "keyApproach": "A better strategy sometimes is: do `n-1` `A`s to go to `2^{n-1}-1` (still less than `target`), then `R` to reverse, then perform `m` `A`s (moving back",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 24,
      "title": "Reorder Data in Log Files",
      "fileName": "Reorder Data in Log Files",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Sorting"
      ],
      "summary": "idea (short)",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 25,
      "title": "Reorganize String",
      "fileName": "Reorganize String",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "Array",
        "String",
        "Greedy"
      ],
      "summary": "restatement: Given a string `s`, rearrange its characters so that no two adjacent characters are the same. Return any valid rearrangement or return `\"\"` if it's impossible.",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 26,
      "title": "Rotting Oranges",
      "fileName": "Rotting Oranges",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "restatement**",
      "keyApproach": "1. Initialize queue with all `2`s (rotten), and count all `1`s (fresh).",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 27,
      "title": "Search Suggestions System",
      "fileName": "Search Suggestions System",
      "difficulty": "Medium",
      "topics": [
        "Graph",
        "Array",
        "String",
        "Sorting",
        "Binary Search"
      ],
      "summary": ". The easiest, clean, and interview-friendly solution is:",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 28,
      "title": "Sequential Digits",
      "fileName": "Sequential Digits",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "statement; that means the BFS layering in that formulation leads to minutes=4. To match the expected output you must ensure minute counting matches the problem's notion. The implementation below is th...",
      "keyApproach": "",
      "complexity": {
        "time": "O(N)",
        "space": "O(N)"
      }
    },
    {
      "id": 29,
      "title": "Sequentially Ordinal Rank Tracker",
      "fileName": "Sequentially Ordinal Rank Tracker",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "String",
        "Greedy",
        "Heap"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 30,
      "title": "Sliding Window Maximum",
      "fileName": "Sliding Window Maximum",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 31,
      "title": "Substring With Largest Variance",
      "fileName": "Substring With Largest Variance",
      "difficulty": "Medium",
      "topics": [
        "Tree",
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "to a maximum subarray (Kadane) style problem by scanning `s` and treating:",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 32,
      "title": "Sum of Subarray Ranges",
      "fileName": "Sum of Subarray Ranges",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers",
        "Stack",
        "Queue"
      ],
      "summary": "s counting subarrays where an element is max/min.",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 33,
      "title": "Sum of Total Strength of Wizards",
      "fileName": "Sum of Total Strength of Wizards",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "Two Pointers",
        "Stack",
        "Queue"
      ],
      "summary": "— classic and a bit tricky. I'll explain the intuition and derive a clean `O(n)` algorithm using monotonic stacks and prefix-of-prefix sums, show why it works, analyze complexity, then give a producti...",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 34,
      "title": "Total Appeal of A String",
      "fileName": "Total Appeal of A String",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "String",
        "Two Pointers"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 35,
      "title": "Trapping Rain Water",
      "fileName": "Trapping Rain Water",
      "difficulty": "Medium",
      "topics": [
        "Array",
        "Two Pointers"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 36,
      "title": "Word Break II",
      "fileName": "Word Break II",
      "difficulty": "Medium",
      "topics": [
        "DFS",
        "Hash Table",
        "Array",
        "String",
        "Dynamic Programming"
      ],
      "summary": "restatement",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "id": 37,
      "title": "Word Ladder",
      "fileName": "Word Ladder",
      "difficulty": "Medium",
      "topics": [
        "BFS",
        "Graph",
        "Hash Table",
        "Array",
        "String"
      ],
      "summary": "",
      "keyApproach": "",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    }
  ],
  "topicIndex": {
    "Binary Tree": [
      1
    ],
    "Tree": [
      1,
      9,
      18,
      20,
      31
    ],
    "BFS": [
      1,
      5,
      9,
      10,
      13,
      18,
      20,
      23,
      25,
      26,
      28,
      29,
      30,
      37
    ],
    "DFS": [
      1,
      5,
      12,
      13,
      20,
      36
    ],
    "Graph": [
      1,
      3,
      5,
      6,
      8,
      17,
      18,
      20,
      21,
      22,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      37
    ],
    "Hash Table": [
      2,
      3,
      4,
      11,
      14,
      20,
      36,
      37
    ],
    "Array": [
      2,
      4,
      5,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      16,
      17,
      18,
      19,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37
    ],
    "String": [
      2,
      4,
      5,
      6,
      7,
      8,
      11,
      12,
      15,
      16,
      17,
      18,
      19,
      21,
      22,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      34,
      36,
      37
    ],
    "Dynamic Programming": [
      2,
      23,
      36
    ],
    "DP": [
      2,
      23
    ],
    "Linked List": [
      3,
      14
    ],
    "Two Pointers": [
      3,
      4,
      7,
      8,
      14,
      16,
      21,
      22,
      26,
      28,
      30,
      31,
      32,
      33,
      34,
      35
    ],
    "Sliding Window": [
      7,
      16
    ],
    "Sorting": [
      8,
      11,
      17,
      22,
      24,
      27
    ],
    "Greedy": [
      9,
      10,
      13,
      17,
      25,
      29
    ],
    "Heap": [
      9,
      10,
      13,
      29
    ],
    "Queue": [
      10,
      16,
      32,
      33
    ],
    "Binary Search": [
      27
    ],
    "Stack": [
      32,
      33
    ]
  },
  "difficultyIndex": {
    "Easy": [],
    "Medium": [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37
    ],
    "Hard": []
  },
  "instructions": {
    "addingNewQuestion": "Simply add a new question file to the repository and run `python generate.py` to automatically update all files.",
    "requiredFields": [
      "id",
      "title",
      "fileName",
      "difficulty",
      "topics",
      "summary",
      "keyApproach",
      "complexity"
    ],
    "optionalFields": [
      "companies",
      "leetcodeNumber",
      "approaches",
      "tags"
    ]
  }
}