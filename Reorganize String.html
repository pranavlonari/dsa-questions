<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reorganize String - DSA Solutions</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.8;
        color: #333;
        background: #f5f7fa;
      }

      /* Header Navigation */
      .top-nav {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 0;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 1000;
      }

      .nav-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
      }

      .nav-brand {
        font-size: 1.3em;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .nav-brand a {
        color: white;
        text-decoration: none;
      }

      .nav-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .nav-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 6px;
        text-decoration: none;
      }

      .nav-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
      }

      .nav-btn.primary {
        background: white;
        color: #667eea;
        font-weight: 600;
      }

      .nav-btn.primary:hover {
        background: #f8f9fa;
      }

      /* Main Container */
      .container {
        max-width: 1200px;
        margin: 30px auto;
        padding: 0 20px;
      }

      /* Question Navigation */
      .question-nav {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
      }

      .nav-group {
        display: flex;
        gap: 10px;
      }

      .question-btn {
        padding: 10px 20px;
        background: white;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
        color: #333;
        text-decoration: none;
      }

      .question-btn:hover:not(:disabled) {
        border-color: #667eea;
        color: #667eea;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
      }

      .question-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      /* Search Bar */
      .search-container {
        position: relative;
        flex: 1;
        min-width: 250px;
        max-width: 400px;
      }

      .search-input {
        width: 100%;
        padding: 10px 40px 10px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 14px;
        transition: all 0.3s;
      }

      .search-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .search-icon {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #999;
      }

      /* Question Header */
      .question-header {
        background: white;
        border-radius: 12px;
        padding: 30px;
        margin-bottom: 25px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      }

      .question-title {
        font-size: 2em;
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 15px;
      }

      .question-meta {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
      }

      .difficulty-badge {
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 600;
      }

      .difficulty-easy {
        background: #d4edda;
        color: #155724;
      }

      .difficulty-medium {
        background: #fff3cd;
        color: #856404;
      }

      .difficulty-hard {
        background: #f8d7da;
        color: #721c24;
      }

      .topic-tag {
        background: #e7f3ff;
        color: #0066cc;
        padding: 6px 14px;
        border-radius: 16px;
        font-size: 13px;
        font-weight: 500;
      }

      /* Action Buttons */
      .action-buttons {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .action-btn {
        padding: 10px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      }

      .action-btn.secondary {
        background: white;
        color: #667eea;
        border: 2px solid #667eea;
      }

      .action-btn.secondary:hover {
        background: #f8f9fa;
      }

      /* Content Area */
      .content-wrapper {
        background: white;
        border-radius: 12px;
        padding: 35px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        margin-bottom: 25px;
      }

      .content-wrapper h1,
      .content-wrapper h2,
      .content-wrapper h3 {
        color: #1a1a1a;
        margin-top: 30px;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #f0f0f0;
      }

      .content-wrapper h1 {
        font-size: 1.8em;
      }

      .content-wrapper h2 {
        font-size: 1.5em;
      }

      .content-wrapper h3 {
        font-size: 1.3em;
      }

      .content-wrapper h1:first-child,
      .content-wrapper h2:first-child,
      .content-wrapper h3:first-child {
        margin-top: 0;
      }

      .content-wrapper p {
        margin-bottom: 15px;
      }

      .content-wrapper ul,
      .content-wrapper ol {
        margin-left: 25px;
        margin-bottom: 15px;
      }

      .content-wrapper li {
        margin-bottom: 8px;
      }

      /* Code Blocks */
      .content-wrapper pre {
        background: #f6f8fa;
        border: 1px solid #e1e4e8;
        border-radius: 8px;
        padding: 20px;
        overflow-x: auto;
        margin: 20px 0;
        position: relative;
      }

      .content-wrapper code {
        font-family: "Courier New", Courier, monospace;
        font-size: 14px;
        line-height: 1.6;
      }

      .content-wrapper p code,
      .content-wrapper li code {
        background: #f6f8fa;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.9em;
        border: 1px solid #e1e4e8;
      }

      /* Copy Button for Code */
      .code-block {
        position: relative;
      }

      .copy-code-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        opacity: 0.8;
        transition: all 0.3s;
      }

      .copy-code-btn:hover {
        opacity: 1;
      }

      .copy-code-btn.copied {
        background: #28a745;
      }

      /* Toast Notification */
      .toast {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background: #28a745;
        color: white;
        padding: 15px 25px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        transform: translateY(100px);
        opacity: 0;
        transition: all 0.3s;
        z-index: 2000;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toast.show {
        transform: translateY(0);
        opacity: 1;
      }

      /* Footer */
      footer {
        background: white;
        border-radius: 12px;
        padding: 25px;
        text-align: center;
        color: #666;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        margin-top: 30px;
      }

      footer a {
        color: #667eea;
        text-decoration: none;
        font-weight: 600;
      }

      footer a:hover {
        text-decoration: underline;
      }

      /* Mobile Responsive */
      @media (max-width: 768px) {
        .nav-container {
          flex-direction: column;
          align-items: flex-start;
        }

        .nav-actions {
          width: 100%;
        }

        .nav-btn {
          flex: 1;
          justify-content: center;
        }

        .question-nav {
          flex-direction: column;
          align-items: stretch;
        }

        .nav-group {
          justify-content: space-between;
          width: 100%;
        }

        .search-container {
          max-width: 100%;
        }

        .question-title {
          font-size: 1.5em;
        }

        .content-wrapper {
          padding: 20px;
        }

        .action-buttons {
          flex-direction: column;
        }

        .action-btn {
          width: 100%;
          justify-content: center;
        }

        .toast {
          right: 15px;
          left: 15px;
          bottom: 15px;
        }
      }

      /* Loading Animation */
      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Print Styles */
      @media print {
        .top-nav,
        .question-nav,
        .action-buttons,
        .toast {
          display: none;
        }

        .container {
          max-width: 100%;
          margin: 0;
          padding: 0;
        }

        .content-wrapper {
          box-shadow: none;
          padding: 0;
        }
      }
    </style>
  </head>
  <body>
    <!-- Top Navigation -->
    <nav class="top-nav">
      <div class="nav-container">
        <div class="nav-brand">
          <span>üöÄ</span>
          <a href="index.html">DSA Questions</a>
        </div>
        <div class="nav-actions">
          <a href="index.html" class="nav-btn primary">
            <span>üìö</span> All Questions
          </a>
          <button onclick="toggleTheme()" class="nav-btn">
            <span id="theme-icon">üåô</span> Theme
          </button>
        </div>
      </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
      <!-- Question Navigation -->
      <div class="question-nav">
        <div class="nav-group">
          <button class="question-btn" id="prevBtn" onclick="navigateToPrev()">
            <span>‚Üê</span> Previous
          </button>
          <button class="question-btn" id="nextBtn" onclick="navigateToNext()">
            Next <span>‚Üí</span>
          </button>
        </div>
        <div class="search-container">
          <input
            type="text"
            class="search-input"
            id="searchInput"
            placeholder="Search questions..."
          />
          <span class="search-icon">üîç</span>
        </div>
        <div class="nav-group">
          <button class="question-btn" onclick="showRandomQuestion()">
            <span>üé≤</span> Random
          </button>
        </div>
      </div>

      <!-- Question Header -->
      <div class="question-header">
        <h1 class="question-title" id="questionTitle">Reorganize String</h1>
        <div class="question-meta" id="questionMeta">
          <span class="difficulty-badge difficulty-medium"
            >Medium</span
          >
          <span class="topic-tag">BFS</span><span class="topic-tag">DFS</span><span class="topic-tag">Graph</span><span class="topic-tag">Array</span><span class="topic-tag">String</span>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="action-buttons">
        <button class="action-btn" onclick="copyContent()">
          <span>üìã</span> Copy All
        </button>
        <button class="action-btn" onclick="copyCode()">
          <span>üíª</span> Copy Code
        </button>
        <button class="action-btn secondary" onclick="exportToPDF()">
          <span>üìÑ</span> Export PDF
        </button>
        <button class="action-btn secondary" onclick="exportToMarkdown()">
          <span>üìù</span> Export MD
        </button>
        <button class="action-btn secondary" onclick="shareQuestion()">
          <span>üîó</span> Share
        </button>
      </div>

      <!-- Question Content -->
      <div class="content-wrapper" id="questionContent"><p>Problem restatement:
Given a string <code>s</code>, rearrange its characters so that no two adjacent characters are the same. Return any valid rearrangement or return <code>""</code> if it's impossible.</p>

<p>Input
<code>s = "aab"</code></p>

<p>Output
<code>"aba"</code></p>

<p>Input
<code>s = "aaab"</code></p>

<p>Output
<code>""</code></p>

<p>Constraints (provided):
<code>1 <= s.length <= 500</code>
<code>s</code> consists of lowercase English letters.</p>

<p>Edge cases to mention:</p>

<ul>
<li><code>s.length == 1</code> -> return <code>s</code>.</li>
<li>All characters same and length > 1 -> impossible.</li>
<li>Many characters but one character frequency too large -> impossible.</li>
<li>Already valid string -> can return original or any valid permutation.</li>
</ul>

<p>Short script to say to interviewer (copy-paste):</p>

<ol>
<li>"Restating: we need any permutation of <code>s</code> where no two adjacent characters are identical. If not possible, return empty string."</li>
<li>"Quick feasibility check: if some character frequency > (n+1)/2, it's impossible."</li>
<li>"I'll use a greedy approach with a max-heap of character frequencies: always pick the two most frequent remaining chars and append them (one by one). This avoids placing same chars adjacent."</li>
<li>"This yields O(n log k) time where k ‚â§ 26, and O(k) extra space. There's also a linear O(n) alternative using index placement because alphabet is small."</li>
<li>"I'll implement the heap approach (straightforward & general). If you prefer, I can show the O(n) index-placement method next."</li>
</ol>

<p>Approaches considered (brief pros/cons):</p>

<ol>
<li><strong>Greedy with Max-Heap (chosen)</strong> ‚Äî Build frequency map, push (freq, char) into max-heap, repeatedly pop top two, append them, push back if still positive. Pros: simple, works for any alphabet. Cons: O(n log k).</li>
<li><strong>Bucket/Index placement (optimized for small alphabet)</strong> ‚Äî Place most frequent char at even indices first, then fill remaining chars; O(n) time, O(1) extra space (k=26). Pros: faster & simpler for limited alphabet. Cons: slightly trickier to reason in interview if not practiced.</li>
<li><strong>Brute-force/backtracking</strong> ‚Äî Try permutations / DFS ‚Äî correct but exponential and impractical for n up to 500.</li>
</ol>

<p>Why greedy works (correctness):
Always placing the currently most frequent character in a spot that is not adjacent to the same character reduces the chance that it will be forced to sit next to itself later. Pairing the two most frequent characters ensures you‚Äôre not left with many copies of one character at the end. The known feasibility condition (maxFreq ‚â§ (n+1)/2) guarantees existence, and the greedy construction achieves it.</p>

<p>Detailed chosen approach (max-heap):</p>

<ul>
<li>Data structures: <code>int[] freq = new int[26]</code>, <code>PriorityQueue<Pair></code> (max-heap by freq).</li>
<li>Steps:</li>
</ul>

<ol>
<li>Count frequencies of characters. Let <code>n = s.length()</code>. If any <code>freq[i] > (n+1)/2</code> return <code>""</code>.</li>
<li>Push all characters with <code>freq > 0</code> into max-heap keyed by frequency.</li>
<li>While heap size >= 2:</li>
</ol>

<ul>
<li>Pop top two <code>(c1,f1)</code> and <code>(c2,f2)</code>. Append <code>c1</code> then <code>c2</code> to a <code>StringBuilder</code>.</li>
<li>decrement f1,f2; if still >0 push back.</li>
</ul>

<ol>
<li>If one char remains in heap, append it (its frequency must be 1 by feasibility).</li>
<li>Return <code>sb.toString()</code>.</li>
</ol>

<ul>
<li>Invariants: adjacent characters appended are always different, and frequencies sum decreases correctly.</li>
</ul>

<p>Complexity:</p>

<ul>
<li>Time: O(n log k) where <code>k</code> = number of distinct characters (‚â§ 26). Practically O(n) since k is small. Counting is O(n), heap operations total O(n log k).</li>
<li>Space: O(k) extra for heap and freq array (k ‚â§ 26) so effectively O(1) extra.</li>
</ul>

<p>Possible optimizations / tradeoffs:</p>

<ul>
<li>Use index-placement O(n) algorithm: place most frequent char at even indices, then fill other chars ‚Äî avoids heap overhead.</li>
<li>When alphabet is large, heap is preferred. For small fixed alphabet, the index method is slightly faster and simpler memory-wise.</li>
</ul>

<p>Java implementation ‚Äî Max-Heap (clean & commented):</p>

<p><pre><code>import java.util.*;

public class ReorganizeString {
    // Pair class for heap
    private static class Pair {
        char ch;
        int freq;
        Pair(char ch, int freq) { this.ch = ch; this.freq = freq; }
    }

    public static String reorganizeString(String s) {
        int n = s.length();
        if (n <= 1) return s;

        // 1) Frequency count
        int[] freq = new int[26];
        for (char c : s.toCharArray()) freq[c - 'a']++;

        // 2) Feasibility check
        int maxFreq = 0;
        for (int f : freq) if (f > maxFreq) maxFreq = f;
        if (maxFreq > (n + 1) / 2) return ""; // impossible

        // 3) Max-heap by frequency
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.freq - a.freq);
        for (int i = 0; i < 26; i++) {
            if (freq[i] > 0) pq.offer(new Pair((char)('a' + i), freq[i]));
        }

        StringBuilder sb = new StringBuilder(n);

        // 4) Greedy: pop two most frequent and append
        while (pq.size() >= 2) {
            Pair p1 = pq.poll();
            Pair p2 = pq.poll();
            sb.append(p1.ch);
            sb.append(p2.ch);
            p1.freq--;
            p2.freq--;
            if (p1.freq > 0) pq.offer(p1);
            if (p2.freq > 0) pq.offer(p2);
        }

        // 5) If one remains, append it
        if (!pq.isEmpty()) sb.append(pq.poll().ch);

        return sb.toString();
    }

    // Optional: faster O(n) method using index placement (no heap)
    public static String reorganizeStringOptimized(String s) {
        int n = s.length();
        int[] freq = new int[26];
        for (char c : s.toCharArray()) freq[c - 'a']++;

        int maxIdx = 0;
        for (int i = 1; i < 26; i++) {
            if (freq[i] > freq[maxIdx]) maxIdx = i;
        }
        if (freq[maxIdx] > (n + 1) / 2) return "";

        char[] res = new char[n];
        int idx = 0;
        // place the most frequent char first at even indices
        while (freq[maxIdx] > 0) {
            res[idx] = (char)('a' + maxIdx);
            idx += 2;
            freq[maxIdx]--;
        }
        // place remaining chars
        for (int i = 0; i < 26; i++) {
            while (freq[i] > 0) {
                if (idx >= n) idx = 1; // switch to odd indices
                res[idx] = (char)('a' + i);
                idx += 2;
                freq[i]--;
            }
        }
        return new String(res);
    }

    // Quick manual tests
    public static void main(String[] args) {
        System.out.println(reorganizeString("aab"));    // "aba" or similar
        System.out.println(reorganizeString("aaab"));   // ""
        System.out.println(reorganizeString("vvvlo"));  // one valid rearrangement
        System.out.println(reorganizeStringOptimized("aab")); // "aba"
    }
}</code></pre></p>

<p>Tests to speak to interviewer:</p>

<ul>
<li><code>"aab"</code> ‚Üí <code>"aba"</code> (valid).</li>
<li><code>"aaab"</code> ‚Üí <code>""</code> (impossible).</li>
<li><code>"a"</code> ‚Üí <code>"a"</code>.</li>
<li><code>"aa"</code> ‚Üí <code>""</code>.</li>
<li><code>"vvvlo"</code> ‚Üí e.g., <code>"vlvov"</code> (any valid).</li>
<li>Long string with many distinct chars ‚Äî check correctness and performance.</li>
</ul>

<p>Closing line to interviewer:
‚ÄúI‚Äôll go with the heap-based greedy since it‚Äôs straightforward and robust</p></div>

      <!-- Footer -->
      <footer>
        <p><strong>Part of DSA Questions Collection</strong></p>
        <p>
          <a href="index.html">Browse All Questions</a> ‚Ä¢
          <a
            href="https://github.com/pranavlonari/dsa-questions"
            target="_blank"
            >GitHub</a
          >
          ‚Ä¢
          <a href="#" onclick="window.print(); return false;">Print</a>
        </p>
        <p style="margin-top: 10px; font-size: 0.9em">
          üí° Interview-ready solutions with detailed explanations
        </p>
      </footer>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast">
      <span>‚úì</span>
      <span id="toastMessage">Copied to clipboard!</span>
    </div>

    <script>
      // Question data from questions.json
      let questionsData = [];
      let currentQuestionIndex = -1;

      // Load questions data
      async function loadQuestionsData() {
        try {
          const response = await fetch("questions.json");
          questionsData = (await response.json()).questions;
          initializeNavigation();
        } catch (error) {
          console.error("Error loading questions:", error);
        }
      }

      // Initialize navigation
      function initializeNavigation() {
        const currentFileName = getCurrentFileName();
        currentQuestionIndex = questionsData.findIndex(
          (q) => q.fileName === currentFileName
        );

        // Update prev/next buttons
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");

        if (currentQuestionIndex <= 0) {
          prevBtn.disabled = true;
        }

        if (
          currentQuestionIndex >= questionsData.length - 1 ||
          currentQuestionIndex === -1
        ) {
          nextBtn.disabled = true;
        }

        // Add code copy buttons
        addCopyButtonsToCode();
      }

      // Get current file name
      function getCurrentFileName() {
        const path = window.location.pathname;
        const fileName = decodeURIComponent(
          path.substring(path.lastIndexOf("/") + 1)
        );
        return fileName || "Reorganize String";
      }

      // Navigate to previous question
      function navigateToPrev() {
        if (currentQuestionIndex > 0) {
          const prevQuestion = questionsData[currentQuestionIndex - 1];
          window.location.href =
            encodeURIComponent(prevQuestion.fileName) + ".html";
        }
      }

      // Navigate to next question
      function navigateToNext() {
        if (
          currentQuestionIndex < questionsData.length - 1 &&
          currentQuestionIndex !== -1
        ) {
          const nextQuestion = questionsData[currentQuestionIndex + 1];
          window.location.href =
            encodeURIComponent(nextQuestion.fileName) + ".html";
        }
      }

      // Show random question
      function showRandomQuestion() {
        if (questionsData.length > 0) {
          const randomIndex = Math.floor(Math.random() * questionsData.length);
          const randomQuestion = questionsData[randomIndex];
          window.location.href =
            encodeURIComponent(randomQuestion.fileName) + ".html";
        }
      }

      // Search functionality
      document.getElementById("searchInput")?.addEventListener("input", (e) => {
        const searchTerm = e.target.value.toLowerCase();
        if (searchTerm.length > 2) {
          const results = questionsData.filter(
            (q) =>
              q.title.toLowerCase().includes(searchTerm) ||
              q.topics.some((t) => t.toLowerCase().includes(searchTerm))
          );
          // Could show dropdown with results
          console.log("Search results:", results);
        }
      });

      // Copy all content
      function copyContent() {
        const content = document.getElementById("questionContent").innerText;
        copyToClipboard(content, "All content copied!");
      }

      // Copy only code blocks
      function copyCode() {
        const codeBlocks = document.querySelectorAll(
          "#questionContent pre code"
        );
        let allCode = "";
        codeBlocks.forEach((block, index) => {
          if (index > 0) allCode += "\n\n// ================\n\n";
          allCode += block.innerText;
        });

        if (allCode) {
          copyToClipboard(allCode, "Code copied!");
        } else {
          showToast("No code found!", "error");
        }
      }

      // Copy to clipboard helper
      function copyToClipboard(text, message) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast(message);
          })
          .catch((err) => {
            console.error("Failed to copy:", err);
            showToast("Failed to copy!", "error");
          });
      }

      // Show toast notification
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const toastMessage = document.getElementById("toastMessage");

        toastMessage.textContent = message;
        toast.style.background = type === "error" ? "#dc3545" : "#28a745";
        toast.classList.add("show");

        setTimeout(() => {
          toast.classList.remove("show");
        }, 3000);
      }

      // Export to PDF
      function exportToPDF() {
        showToast("Preparing PDF...", "success");
        setTimeout(() => {
          window.print();
        }, 500);
      }

      // Export to Markdown
      function exportToMarkdown() {
        const title = document.getElementById("questionTitle").innerText;
        const content = document.getElementById("questionContent").innerText;

        const markdown = `# ${title}\n\n${content}`;

        const blob = new Blob([markdown], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${title}.md`;
        a.click();
        URL.revokeObjectURL(url);

        showToast("Markdown exported!");
      }

      // Share question
      function shareQuestion() {
        const title = document.getElementById("questionTitle").innerText;
        const url = window.location.href;

        if (navigator.share) {
          navigator
            .share({
              title: title,
              url: url,
            })
            .then(() => {
              showToast("Shared successfully!");
            })
            .catch(() => {
              copyToClipboard(url, "Link copied!");
            });
        } else {
          copyToClipboard(url, "Link copied!");
        }
      }

      // Add copy buttons to code blocks
      function addCopyButtonsToCode() {
        const codeBlocks = document.querySelectorAll("#questionContent pre");
        codeBlocks.forEach((block, index) => {
          const button = document.createElement("button");
          button.className = "copy-code-btn";
          button.innerHTML = "üìã Copy";
          button.onclick = function () {
            const code =
              block.querySelector("code")?.innerText || block.innerText;
            copyToClipboard(code, "Code copied!");
            button.innerHTML = "‚úì Copied";
            button.classList.add("copied");
            setTimeout(() => {
              button.innerHTML = "üìã Copy";
              button.classList.remove("copied");
            }, 2000);
          };
          block.style.position = "relative";
          block.appendChild(button);
        });
      }

      // Theme toggle (optional)
      function toggleTheme() {
        // Implement dark mode if desired
        showToast("Theme toggle coming soon!");
      }

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        // Alt + Left Arrow - Previous
        if (e.altKey && e.key === "ArrowLeft") {
          navigateToPrev();
        }
        // Alt + Right Arrow - Next
        if (e.altKey && e.key === "ArrowRight") {
          navigateToNext();
        }
        // Ctrl + K - Search
        if (e.ctrlKey && e.key === "k") {
          e.preventDefault();
          document.getElementById("searchInput").focus();
        }
      });

      // Initialize on page load
      loadQuestionsData();
    </script>
  </body>
</html>
